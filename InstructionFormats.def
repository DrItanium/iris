/**
 * This file contains the binding between a given operation and its corresponding
 * format. Update this file when adding new type information
 */
// error is just zero and is not part of a group
// X(name, Format, opcode)
#define Opcode(name, format, opcode) X(name, format, ((opcode) << 24))
//-----------------------------------------------------------------------------
// Arithmetic
//-----------------------------------------------------------------------------
// Fields are: 0b000,0,K,TTT
// Where:
// C = Major Opcode
// K = Integer? else Ordinal
// T = Operation
#define GroupArithmetic   0b00000000
#define OpcodeError       0b00000000
#define OpcodeAdd         0b00000001
#define OpcodeSubtract    0b00000010
#define OpcodeMultiply    0b00000011
#define OpcodeDivide      0b00000100
#define OpcodeRemainder   0b00000101
#define OpcodeShiftLeft   0b00000110
#define OpcodeShiftRight  0b00000111

#define KindOrdinal       0b00000000
#define KindInteger       0b00001000
    Opcode(Error,               ZeroRegister,  GroupArithmetic | OpcodeError)
    Opcode(AddOrdinal,          ThreeRegister, GroupArithmetic | OpcodeAdd | KindOrdinal)
    Opcode(AddInteger,          ThreeRegister, GroupArithmetic | OpcodeAdd | KindInteger)
    Opcode(SubtractOrdinal,     ThreeRegister, GroupArithmetic | OpcodeSubtract | KindOrdinal)
    Opcode(SubtractInteger,     ThreeRegister, GroupArithmetic | OpcodeSubtract | KindInteger)
    Opcode(MultiplyOrdinal,     ThreeRegister, GroupArithmetic | OpcodeMultiply | KindOrdinal)
    Opcode(MultiplyInteger,     ThreeRegister, GroupArithmetic | OpcodeMultiply | KindInteger)
    Opcode(DivideOrdinal,       ThreeRegister, GroupArithmetic | OpcodeDivide | KindOrdinal)
    Opcode(DivideInteger,       ThreeRegister, GroupArithmetic | OpcodeDivide | KindInteger)
    Opcode(RemainderOrdinal,    ThreeRegister, GroupArithmetic | OpcodeRemainder | KindOrdinal)
    Opcode(RemainderInteger,    ThreeRegister, GroupArithmetic | OpcodeRemainder | KindInteger)
    Opcode(ShiftLeftOrdinal,    ThreeRegister, GroupArithmetic | OpcodeShiftLeft | KindOrdinal)
    Opcode(ShiftLeftInteger,    ThreeRegister, GroupArithmetic | OpcodeShiftLeft | KindInteger)
    Opcode(ShiftRightOrdinal,   ThreeRegister, GroupArithmetic | OpcodeShiftRight | KindOrdinal)
    Opcode(ShiftRightInteger,   ThreeRegister, GroupArithmetic | OpcodeShiftRight | KindInteger)
#undef KindOrdinal
#undef KindInteger
#undef GroupArithmetic
#undef OpcodeAdd
#undef OpcodeSubtract 
#undef OpcodeMultiply 
#undef OpcodeDivide 
#undef OpcodeRemainder 
#undef OpcodeShiftLeft 
#undef OpcodeShiftRight 
//-----------------------------------------------------------------------------
// Bitwise 
//-----------------------------------------------------------------------------
// format is: 0b101,0,A,N,TT
// where:
// N: Not the result?
// T: The operation
// A: Imm16 argument
#define GroupBitwise      0b10100000
#define OpcodeNot         0b00000000
#define OpcodeAnd         0b00000001
#define OpcodeOr          0b00000010
#define OpcodeXor         0b00000011
#define NotTheResult      0b00000100
#define ArgumentIsImm16   0b00001000
    Opcode(BitwiseNot,    TwoRegister,      GroupBitwise | OpcodeNot)
    Opcode(Move,          TwoRegister,      GroupBitwise | OpcodeNot | NotTheResult)
    Opcode(LoadImmediate, OneRegisterU16,   GroupBitwise | OpcodeNot | NotTheResult | ArgumentIsImm16)
    Opcode(BitwiseAnd,    ThreeRegister,    GroupBitwise | OpcodeAnd)
    Opcode(BitwiseNand,   ThreeRegister,    GroupBitwise | OpcodeAnd | NotTheResult)
    Opcode(BitwiseOr,     ThreeRegister,    GroupBitwise | OpcodeOr)
    Opcode(BitwiseNor,    ThreeRegister,    GroupBitwise | OpcodeOr | NotTheResult)
    Opcode(BitwiseXor,    ThreeRegister,    GroupBitwise | OpcodeXor)
    Opcode(BitwiseXnor,   ThreeRegister,    GroupBitwise | OpcodeXor | NotTheResult)
#undef GroupBitwise
#undef OpcodeNot
#undef OpcodeAnd
#undef OpcodeOr
#undef OpcodeXor
#undef NotTheResult
#undef ArgumentIsImm16
//-----------------------------------------------------------------------------
// Memory
//-----------------------------------------------------------------------------
// format is: 0b010,L,A,SS
// where 
// L: Load? else Store
// A: Arg1 Is Imm? else register + (offset imm)
#define GroupMemory      0b010'0'0'0'00
#define LoadOperation    0b000'0'1'0'00 
#define StoreOperation   0b000'0'0'0'00 
#define Arg1IsImm        0b000'0'0'1'00 
#define Arg1IsRegister   0b000'0'0'0'00 
#define SpaceCode        0b000'0'0'0'00
#define SpaceData        0b000'0'0'0'01
#define SpaceStack       0b000'0'0'0'10
#define SpaceIO          0b000'0'0'0'11
    Opcode(CodeLoadWithOffset,            TwoRegisterU8,  GroupMemory | LoadOperation | Arg1IsRegister | SpaceCode)
    Opcode(CodeLoadFromImmediateAddress,  OneRegisterU16, GroupMemory | LoadOperation | Arg1IsImm      | SpaceCode)
    Opcode(CodeStoreWithOffset,           TwoRegisterU8,  GroupMemory | StoreOperation | Arg1IsRegister | SpaceCode)
    Opcode(CodeStoreToImmediateAddress,   OneRegisterU16, GroupMemory | StoreOperation | Arg1IsImm      | SpaceCode)
    Opcode(DataLoadWithOffset,            TwoRegisterU8,  GroupMemory | LoadOperation | Arg1IsRegister | SpaceData)
    Opcode(DataLoadFromImmediateAddress,  OneRegisterU16, GroupMemory | LoadOperation | Arg1IsImm      | SpaceData)
    Opcode(DataStoreWithOffset,           TwoRegisterU8,  GroupMemory | StoreOperation | Arg1IsRegister | SpaceData)
    Opcode(DataStoreToImmediateAddress,   OneRegisterU16, GroupMemory | StoreOperation | Arg1IsImm      | SpaceData)
    Opcode(StackLoadWithOffset,           TwoRegisterU8,  GroupMemory | LoadOperation | Arg1IsRegister | SpaceStack)
    Opcode(StackLoadFromImmediateAddress, OneRegisterU16, GroupMemory | LoadOperation | Arg1IsImm      | SpaceStack)
    Opcode(StackStoreWithOffset,          TwoRegisterU8,  GroupMemory | StoreOperation | Arg1IsRegister | SpaceStack)
    Opcode(StackStoreToImmediateAddress,  OneRegisterU16, GroupMemory | StoreOperation | Arg1IsImm      | SpaceStack)
    Opcode(IOLoadWithOffset,              TwoRegisterU8,  GroupMemory | LoadOperation | Arg1IsRegister | SpaceIO)
    Opcode(IOLoadFromImmediateAddress,    OneRegisterU16, GroupMemory | LoadOperation | Arg1IsImm      | SpaceIO)
    Opcode(IOStoreWithOffset,             TwoRegisterU8,  GroupMemory | StoreOperation | Arg1IsRegister | SpaceIO)
    Opcode(IOStoreToImmediateAddress,     OneRegisterU16, GroupMemory | StoreOperation | Arg1IsImm      | SpaceIO)
#undef GroupMemory
#undef LoadOperation
#undef StoreOperation
#undef Arg1IsImm
#undef Arg1IsRegister
#undef SpaceCode
#undef SpaceData
#undef SpaceStack
#undef SpaceIO
//-----------------------------------------------------------------------------
// Compare
//-----------------------------------------------------------------------------
// Format is 0b001,0000,K
// Where K is Integer? else Ordinal
#define GroupCompare    0b00100000
#define KindOrdinal     0b00000000
#define KindInteger     0b00000001
    Opcode(CompareOrdinal, ThreeRegister, GroupCompare | KindOrdinal)
    Opcode(CompareInteger, ThreeRegister, GroupInteger | KindInteger)
#undef GroupCompare
#undef KindOrdinal
#undef KindInteger
//-----------------------------------------------------------------------------
// Branches
//-----------------------------------------------------------------------------
// these code kinds and descriptions are taken from how the i960 works with 
// conditions. The difference is that iris does not have a single condition code
// register. Instead one of the gprs is used for that purpose since there is a
// generous number of registers provided.
#define BranchIfUnordered       0b00000000
#define BranchIfGreater         0b00000001
#define BranchIfEqual           0b00000010
#define BranchIfGreaterOrEqual  0b00000011
#define BranchIfLess            0b00000100
#define BranchIfNotEqual        0b00000101
#define BranchIfLessOrEqual     0b00000110
#define BranchIfOrdered         0b00000111
//-----------------------------------------------------------------------------
// Branch Immediate
//-----------------------------------------------------------------------------
// Top level format is 0b011,C,xxxx
// where 
// C: Branch Conditional? else Link
// if C is 1 then the format is: 0b011,1,R,YYY, this is known as the conditional immediate form
// R: Relative? else Absolute
// Y: Condition codes defined above
// if C is 0 then the format is: 0b011,0,R,000, this is known as the link immediate form
// R: Relative? else Absolute
// there is not enough space in the encoding to allow conditional jump and link in a single instruction
#define GroupBranchImm  0b01100000
#define IsConditional   0b00010000
#define IsLink          0b00000000
#define RelativeJump    0b00001000 
#define AbsoluteJump    0b00000000 
    Opcode(NeverBranchAbsoluteImmediate, OneRegisterS16, GroupBranchImm | IsConditional | AbsoluteJump | BranchIfUnordered)
    Opcode(NeverBranchRelativeImmediate, OneRegisterS16, GroupBranchImm | IsConditional | RelativeJump | BranchIfUnordered)
    Opcode(BranchGreaterAbsoluteImmediate, OneRegisterU16, GroupBranchImm | IsConditional | AbsoluteJump | BranchIfGreater)
    Opcode(BranchGreaterRelativeImmediate, OneRegisterS16, GroupBranchImm | IsConditional | RelativeJump | BranchIfGreater)
    Opcode(BranchEqualAbsoluteImmediate, OneRegisterU16, GroupBranchImm | IsConditional | AbsoluteJump | BranchIfEqual)
    Opcode(BranchEqualRelativeImmediate, OneRegisterS16, GroupBranchImm | IsConditional | RelativeJump | BranchIfEqual)
    Opcode(BranchGreaterOrEqualAbsoluteImmediate, OneRegisterU16, GroupBranchImm | IsConditional | AbsoluteJump | BranchIfGreaterOrEqual)
    Opcode(BranchGreaterOrEqualRelativeImmediate, OneRegisterS16, GroupBranchImm | IsConditional | RelativeJump | BranchIfGreaterOrEqual)
    Opcode(BranchLessAbsoluteImmediate, OneRegisterU16, GroupBranchImm | IsConditional | AbsoluteJump | BranchIfLess)
    Opcode(BranchLessRelativeImmediate, OneRegisterS16, GroupBranchImm | IsConditional | RelativeJump | BranchIfLess)
    Opcode(BranchNotEqualAbsoluteImmediate, OneRegisterU16, GroupBranchImm | IsConditional | AbsoluteJump | BranchIfNotEqual)
    Opcode(BranchNotEqualRelativeImmediate, OneRegisterS16, GroupBranchImm | IsConditional | RelativeJump | BranchIfNotEqual)
    Opcode(BranchLessOrEqualAbsoluteImmediate, OneRegisterU16, GroupBranchImm | IsConditional | AbsoluteJump | BranchIfLessOrEqual)
    Opcode(BranchLessOrEqualRelativeImmediate, OneRegisterS16, GroupBranchImm | IsConditional | RelativeJump | BranchIfLessOrEqual)
    Opcode(BranchUnconditionalAbsoluteImmediate, OneRegisterU16, GroupBranchImm | IsConditional | AbsoluteJump | BranchIfOrdered)
    Opcode(BranchUnconditionalRelativeImmediate, OneRegisterS16, GroupBranchImm | IsConditional | RelativeJump | BranchIfOrdered)
        
    // all unconditional one way branches are redefined in terms of the conditional
    // versions
    Branch(ConditionalImmediate, OneRegisterU16)
    Branch(ConditionalRelativeImmediate, OneRegisterS16)
    Branch(RelativeImmediateAndLink, OneRegisterS16)
    Branch(ImmediateAndLink, OneRegisterU16)
    Branch(ConditionalRegisterAndLink, ThreeRegister)
#undef GroupBranchImm
#undef IsConditional
#undef IsLink
#undef RelativeJump
#undef AbsoluteJump
//-----------------------------------------------------------------------------
// Branch Register
//-----------------------------------------------------------------------------
#define GroupBranchReg  0b10000000
#undef GroupBranchReg
//-----------------------------------------------------------------------------
#undef BranchIfUnordered       // 0b00000000
#undef BranchIfGreater         // 0b00000001
#undef BranchIfEqual           // 0b00000010
#undef BranchIfGreaterOrEqual  // 0b00000011
#undef BranchIfLess            // 0b00000100
#undef BranchIfNotEqual        // 0b00000101
#undef BranchIfLessOrEqual     // 0b00000110
#undef BranchIfOrdered         // 0b00000111

#undef Opcode
