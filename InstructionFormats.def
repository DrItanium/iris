/**
 * This file contains the binding between a given operation and its corresponding
 * format. Update this file when adding new type information
 */
// error is just zero and is not part of a group
// X(name, opcode)
#define Operation(name, opcode) X(name, (static_cast<EncodedInstruction>((opcode))))
//-------------------------------------------------------------------------------------------------
// Iris instructions are 32-bits wide and are carved up into four separate
// sections as follows:
// [0,  7] Argument2/Source2/Immediate8
// [8, 15] Argument1/Source1
// [16,23] Argument0/Destination
// [24,31] Opcode
// 
// With this design we can also merge Source2 and Source1 together to make a
// 16-bit immediate as well so we add this as well to the design:
// [0, 16] Immediate16

// Thus there are really a handful of forms with offshoots being degenerate
// cases. The forms are:
// 1) Three Register
// 1a) Two Register (Argument2 is 0)
// 1b) Two Register plus Imm8 (Argument2 does not refer to a register index)
// 2) One Register plus Imm16
// 2a) One Register (Imm16 is zero)
// 2b) Zero Register / Zero Argument (Argument0 and Imm16 are zero)
// 3) Imm24 (unused but theoretically possible)
//
// The rest of this file will describe the instructions and forms. Here are
// some other terms that may help if you are not familiar with them:
// 
// 1) Ordinal - Unsigned number
// 2) Integer - Signed number
//-------------------------------------------------------------------------------------------------
// The 8-bit opcode is divided generically into two parts:
// 0bMMMXXXXX
// where 0bMMM is the major opcode kind. There are a total of 8 major opcode
// groups with not all of the groups currently in use. The XXXXX portion (or
// minor opcode kind) is defined by the group to describe actions to perform 
// under that major kind.
//
// The groups are:
// 0b000XXXXX - Arithmetic
// 0b001XXXXX - Compare
// 0b010XXXXX - Memory
// 0b011XXXXX - Branch
// 0b100XXXXX - Bitwise
// 0b101XXXXX - Reserved for future use
// 0b110XXXXX - Reserved for future use
// 0b111XXXXX - Reserved for future use
//-------------------------------------------------------------------------------------------------
// Arithmetic
// Arithmetic operations consist of:
// - Error
// - Add
// - Subtract
// - Multiply
// - Divide
// - Remainder
// - Shift Left
// - Shift Right
//
// With the exception of Error, the other arithmetic operations have integer
// and ordinal forms. This comes from the very elegantly designed i960
// processor. 
// The bits of arithmetic instructions are as follows:
// 0b000,0,TTT,K
// where K is the operation kind with the following legend:
//  k == 0 -> Treat sources as ordinals
//  k == 1 -> Treat sources as integers
// where TTT is the operation code, here are the following values:
//  0b000 -> Error
//  0b001 -> Add
//  0b010 -> Subtract 
//  0b011 -> Multiply 
//  0b100 -> Divide 
//  0b101 -> Remainder 
//  0b110 -> Shift Left 
//  0b111 -> Shift Right
//
// the most significant bit of the minor opcode kind is reserved and currently
// goes unused. It must be set to zero
//-------------------------------------------------------------------------------------------------
/**
  * This is to make sure that a zero instruction is considered to be an error
  */
Operation(Error,                                     GroupArithmetic | bits::OperationError)
/**
  * Form: Three Register
  * Logic: reg[dest] = reg[src1] + reg[src2}
  */
Operation(AddOrdinal,                                GroupArithmetic | bits::OperationAdd | bits::KindOrdinal)
Operation(AddInteger,                                GroupArithmetic | bits::OperationAdd | bits::KindInteger)
/**
  * Form: Three Register
  * Logic: reg[dest] = reg[src1] - reg[src2]
  */
Operation(SubtractOrdinal,                           GroupArithmetic | bits::OperationSubtract | bits::KindOrdinal)
Operation(SubtractInteger,                           GroupArithmetic | bits::OperationSubtract | bits::KindInteger)
/**
  * Form: Three Register
  * Logic: reg[dest] = reg[src1] * reg[src2]
  */
Operation(MultiplyOrdinal,                           GroupArithmetic | bits::OperationMultiply | bits::KindOrdinal)
Operation(MultiplyInteger,                           GroupArithmetic | bits::OperationMultiply | bits::KindInteger)
/**
  * Form: Three Register
  * Logic: reg[dest] = reg[src1] / reg[src2]
  * NOTE: Will error if reg[src2] is zero
  */
Operation(DivideOrdinal,                             GroupArithmetic | bits::OperationDivide | bits::KindOrdinal)
Operation(DivideInteger,                             GroupArithmetic | bits::OperationDivide | bits::KindInteger)
/**
  * Form: Three Register
  * Logic: reg[dest] = reg[src1] % reg[src2]
  * NOTE: Will error if reg[src2] is zero
  */
Operation(RemainderOrdinal,                          GroupArithmetic | bits::OperationRemainder | bits::KindOrdinal)
Operation(RemainderInteger,                          GroupArithmetic | bits::OperationRemainder | bits::KindInteger)
/**
  * Form: Three Register
  * Logic: reg[dest] = (reg[src2] > 31) ? (reg[src1] << reg[src2]) : 0
  */

Operation(ShiftLeftOrdinal,                          GroupArithmetic | bits::OperationShiftLeft | bits::KindOrdinal)
Operation(ShiftLeftInteger,                          GroupArithmetic | bits::OperationShiftLeft | bits::KindInteger)
/**
  * Form: Three Register
  * Logic: reg[dest] = (reg[src2] > 31) ? (reg[src1] >> reg[src2]) : 0
  */
Operation(ShiftRightOrdinal,                         GroupArithmetic | bits::OperationShiftRight | bits::KindOrdinal)
Operation(ShiftRightInteger,                         GroupArithmetic | bits::OperationShiftRight | bits::KindInteger)
//-------------------------------------------------------------------------------------------------
// Bitwise operations include:
// And, Or, Not, Xor, Nand, Nor, and Xnor. The bitwise group is divided into
// the following full pattern:
// 0b101,0,A,N,TT
// Where:
//
// A denotes if the bitwise operation treats src0 and src1 as an
// immediate 16 bit value (changes the instruction form), 
//    A == 1 -> Treat arg1 and arg2 as a single 16-bit ordinal, this implies a
//              destructive modification in the case of the binary operations
//    A == 0 -> Treat arg1 and arg2 as separate registers, implies a binary
//              non-destructive operation
//
// N says to not the result of the operation before storing in destination
//    N == 1 -> Not the result of the operation before storing in destination
//              This can be used to perform a load immediate 16 with bitwise not
//              and A == 1.
//              Can also be used combined with binary not and A==0 to do a
//              register transfer. 
//              This is combined with and, or, and xor to make nand, nor, and
//              xnor operations
//    N == 0 -> Store the result of the operation as is in the destination
// 
// TT is the operation type
//   TT = 0b00 -> bitwise not
//   TT = 0b01 -> bitwise and
//   TT = 0b10 -> bitwise or
//   TT = 0b11 -> bitwise xor
Operation(Move,                                      GroupBitwise    | bits::OperationNot | bits::NotTheResult)
Operation(BitwiseNot,                                GroupBitwise    | bits::OperationNot)
Operation(BitwiseAnd,                                GroupBitwise    | bits::OperationAnd)
Operation(BitwiseNand,                               GroupBitwise    | bits::OperationAnd | bits::NotTheResult)
Operation(BitwiseOr,                                 GroupBitwise    | bits::OperationOr)
Operation(BitwiseNor,                                GroupBitwise    | bits::OperationOr | bits::NotTheResult)
Operation(BitwiseXor,                                GroupBitwise    | bits::OperationXor)
Operation(BitwiseXnor,                               GroupBitwise    | bits::OperationXor | bits::NotTheResult)
//-------------------------------------------------------------------------------------------------
// Memory Operations (load, store, and misc register transfer)
// 
// Format is: 0b010,L,XXXX
// Where
// L is load when set
//      store when clear
// When L is set the format is:
//    0b0101,KK,XX 
//   where KK is:
//    0b00 -> Word
//    0b01 -> Half
//    0b10 -> Byte
//    0b11 -> Immediate16
//   When KK == 0b11 the rest of the bits are: S0
//    where S is shift imm16 by 16 before storing when set
//            is load imm16 into lower 16 when clear
//    lowest most bit is not used
//   When KK != 0b11 the rest of the bits are: UC
//    where U is update source register if set
//    where C is treat the arg2 as:
//        signed imm8 when C is clear
//        register with signed contents when C is set
// 
// When L is clear the format is very similar:
//    0b0101,KK,XX 
//   where KK is:
//    0b00 -> Word
//    0b01 -> Half
//    0b10 -> Byte
//    0b11 -> Reserved
//   When KK != 0b11 the rest of the bits are: UC
//    where U is update source register if set
//    where C is treat the arg2 as:
//        signed imm8 when C is clear
//        register with signed contents when C is set

Operation(LoadWordWithImmediateOffset,           GroupMemory | bits::LoadOperation | bits::MemoryWidthWord | bits::DoNotUpdateSource | bits::TreatArg2AsSignedImm8)
Operation(LoadWordWithImmediateOffsetAndUpdate,  GroupMemory | bits::LoadOperation | bits::MemoryWidthWord | bits::UpdateSource | bits::TreatArg2AsSignedImm8)
Operation(LoadWordWithRegisterOffset,            GroupMemory | bits::LoadOperation | bits::MemoryWidthWord | bits::DoNotUpdateSource | bits::TreatArg2AsRegisterIndex)
Operation(LoadWordWithRegisterOffsetAndUpdate,   GroupMemory | bits::LoadOperation | bits::MemoryWidthWord | bits::UpdateSource | bits::TreatArg2AsRegisterIndex)
Operation(LoadHalfWithImmediateOffset,           GroupMemory | bits::LoadOperation | bits::MemoryWidthHalf | bits::DoNotUpdateSource | bits::TreatArg2AsSignedImm8)
Operation(LoadHalfWithImmediateOffsetAndUpdate,  GroupMemory | bits::LoadOperation | bits::MemoryWidthHalf | bits::UpdateSource | bits::TreatArg2AsSignedImm8)
Operation(LoadHalfWithRegisterOffset,            GroupMemory | bits::LoadOperation | bits::MemoryWidthHalf | bits::DoNotUpdateSource | bits::TreatArg2AsRegisterIndex)
Operation(LoadHalfWithRegisterOffsetAndUpdate,   GroupMemory | bits::LoadOperation | bits::MemoryWidthHalf | bits::UpdateSource | bits::TreatArg2AsRegisterIndex)
Operation(LoadByteWithImmediateOffset,           GroupMemory | bits::LoadOperation | bits::MemoryWidthByte | bits::DoNotUpdateSource | bits::TreatArg2AsSignedImm8)
Operation(LoadByteWithImmediateOffsetAndUpdate,  GroupMemory | bits::LoadOperation | bits::MemoryWidthByte | bits::UpdateSource | bits::TreatArg2AsSignedImm8)
Operation(LoadByteWithRegisterOffset,            GroupMemory | bits::LoadOperation | bits::MemoryWidthByte | bits::DoNotUpdateSource | bits::TreatArg2AsRegisterIndex)
Operation(LoadByteWithRegisterOffsetAndUpdate,   GroupMemory | bits::LoadOperation | bits::MemoryWidthByte | bits::UpdateSource | bits::TreatArg2AsRegisterIndex)
Operation(StoreWordWithImmediateOffset,          GroupMemory | bits::StoreOperation | bits::MemoryWidthWord | bits::DoNotUpdateSource | bits::TreatArg2AsSignedImm8)
Operation(StoreWordWithImmediateOffsetAndUpdate, GroupMemory | bits::StoreOperation | bits::MemoryWidthWord | bits::UpdateSource | bits::TreatArg2AsSignedImm8)
Operation(StoreWordWithRegisterOffset,           GroupMemory | bits::StoreOperation | bits::MemoryWidthWord | bits::DoNotUpdateSource | bits::TreatArg2AsRegisterIndex)
Operation(StoreWordWithRegisterOffsetAndUpdate,  GroupMemory | bits::StoreOperation | bits::MemoryWidthWord | bits::UpdateSource | bits::TreatArg2AsRegisterIndex)
Operation(StoreHalfWithImmediateOffset,          GroupMemory | bits::StoreOperation | bits::MemoryWidthHalf | bits::DoNotUpdateSource | bits::TreatArg2AsSignedImm8)
Operation(StoreHalfWithImmediateOffsetAndUpdate, GroupMemory | bits::StoreOperation | bits::MemoryWidthHalf | bits::UpdateSource | bits::TreatArg2AsSignedImm8)
Operation(StoreHalfWithRegisterOffset,           GroupMemory | bits::StoreOperation | bits::MemoryWidthHalf | bits::DoNotUpdateSource | bits::TreatArg2AsRegisterIndex)
Operation(StoreHalfWithRegisterOffsetAndUpdate,  GroupMemory | bits::StoreOperation | bits::MemoryWidthHalf | bits::UpdateSource | bits::TreatArg2AsRegisterIndex)
Operation(StoreByteWithImmediateOffset,          GroupMemory | bits::StoreOperation | bits::MemoryWidthByte | bits::DoNotUpdateSource | bits::TreatArg2AsSignedImm8)
Operation(StoreByteWithImmediateOffsetAndUpdate, GroupMemory | bits::StoreOperation | bits::MemoryWidthByte | bits::UpdateSource | bits::TreatArg2AsSignedImm8)
Operation(StoreByteWithRegisterOffset,           GroupMemory | bits::StoreOperation | bits::MemoryWidthByte | bits::DoNotUpdateSource | bits::TreatArg2AsRegisterIndex)
Operation(StoreByteWithRegisterOffsetAndUpdate,  GroupMemory | bits::StoreOperation | bits::MemoryWidthByte | bits::UpdateSource | bits::TreatArg2AsRegisterIndex)
Operation(LoadImmediate16,                       GroupMemory | bits::LoadOperation | bits::MemoryWidthImmediate16 | bits::DoNotShiftImmediateBy16)
Operation(LoadImmediateShifted16,                GroupMemory | bits::LoadOperation | bits::MemoryWidthImmediate16 | bits::ShiftImmediateBy16)

//-------------------------------------------------------------------------------------------------
// Compare operations are pretty straight forward, 
// the act exactly like the i960 versions of these instructions but store the conditional result
// in the destination register instead of custom conditional bits
// The form is as follows:
// 0b001,0000,K
// where K denotes Compare Ordinal if clear
//                 Compare Integer if set
// The result of the compare is a three bit code stored in the lowest 3 bits of the destination register
//
// The algorithm is as follows:
/*
   if (reg[src1] < reg[src2]) {
        reg[dest] = 0b100
   } else if (reg[src1] == reg[src2]) {
        reg[dest] = 0b010
   } else {
        reg[dest] = 0b001 
   }
*/
// This implies that the bit pattern is as follows:
// 0bLEG
// Where L means less than
//       E means equal to
//       G means greater than
// thus we can extrapolate all of the different relations by masking off the 3 bit pattern as follows:
/*
   0b000 -> is unordered (useful when dealing with floating point but in integer only it means never branch)
   0b001 -> is greater than
   0b010 -> is equal
   0b011 -> is greater than or equal
   0b100 -> is less than
   0b101 -> is not equal
   0b110 -> is less than or equal
   0b111 -> is ordered (always branch :D)
*/
// with all of these "masks" we can always extrapolate the correct information as needed
// these instructions are both three register forms
Operation(CompareOrdinal,                            GroupCompare    | bits::KindOrdinal)
Operation(CompareInteger,                            GroupCompare    | bits::KindInteger)
//-------------------------------------------------------------------------------------------------
// 0b011YXXXX 
// Where Y denotes:
// Register when set
// Immediate when clear
// Thus the immediate forms are:
// 0b0110CXXX where C describes:
//    Conditional when set
//    Link when clear
// It is not possible to have a conditional and link immediate branch due to lack of register space. Plenty of encoding
// space exists :D
// Immediate branches are always relative to the current ip, thus you can only jump 32k forward and back from
// where you currently are. This is not that much of a problem to be honest.
// When C is set the form is:
//  0b01101FFF
//  where FFF is the conditional kind as described as follows (same as the compre format...duh):
/*
   0b000 -> is unordered (useful when dealing with floating point but in integer only it means never branch)
   0b001 -> is greater than
   0b010 -> is equal
   0b011 -> is greater than or equal
   0b100 -> is less than
   0b101 -> is not equal
   0b110 -> is less than or equal
   0b111 -> is ordered (always branch :D)
*/
// When C is clear the form is (link immediate):
// 0b01100000
// there is only one instruction in this format.
// When Y is set then we get the following form:
// 0b0111PFFF
// Where FFF is the conditional mask to use in the same form as above:
/*
   0b000 -> is unordered (useful when dealing with floating point but in integer only it means never branch)
   0b001 -> is greater than
   0b010 -> is equal
   0b011 -> is greater than or equal
   0b100 -> is less than
   0b101 -> is not equal
   0b110 -> is less than or equal
   0b111 -> is ordered (always branch :D)
*/

// Where P is:
// ConditionalBranchAndLink on clear
// Select on set
//
// Since IRIS has so many hardwired registers, it is possible to describe all branch register in terms of these two
// operations. Select is provided as a convience to make describing if then else conditions in a single instruction

// The format of the conditional branch and link is 
// arg0: branch destination
// arg1: cond (set this to a hardwired register to force a jump if desired or zero if not :D)
// arg2: link register (set this to a hardwired register to prevent the write from taking place)


// the format of the select operation is as follows:
// arg0: condition (can do some interesting things with the hardwired registers if so desired)
// arg1: address to jump to when condition is met
// arg2: address to jump to when condition is not met



//-------------------------------------------------------------------------------------------------
Operation(BranchIfUnorderedImmediate,                GroupBranch | bits::ImmediateBranch | bits::IsConditional | bits::BranchIfUnordered)
Operation(BranchIfGreaterImmediate,                  GroupBranch | bits::ImmediateBranch | bits::IsConditional | bits::BranchIfGreater)
Operation(BranchIfEqualImmediate,                    GroupBranch | bits::ImmediateBranch | bits::IsConditional | bits::BranchIfEqual)
Operation(BranchIfGreaterOrEqualImmediate,           GroupBranch | bits::ImmediateBranch | bits::IsConditional | bits::BranchIfGreaterOrEqual)
Operation(BranchIfLessImmediate,                     GroupBranch | bits::ImmediateBranch | bits::IsConditional | bits::BranchIfLess)
Operation(BranchIfNotEqualImmediate,                 GroupBranch | bits::ImmediateBranch | bits::IsConditional | bits::BranchIfNotEqual)
Operation(BranchIfLessOrEqualImmediate,              GroupBranch | bits::ImmediateBranch | bits::IsConditional | bits::BranchIfLessOrEqual)
Operation(BranchIfOrderedImmediate,                  GroupBranch | bits::ImmediateBranch | bits::IsConditional | bits::BranchIfOrdered)
Operation(BranchImmediateAndLink,                    GroupBranch | bits::ImmediateBranch | bits::IsLink)
Operation(BranchIfUnorderedToRegisterAndLink,        GroupBranch | bits::RegisterBranch | bits::IsConditionalBranchAndLink | bits::BranchIfUnordered)
Operation(BranchIfGreaterToRegisterAndLink,          GroupBranch | bits::RegisterBranch | bits::IsConditionalBranchAndLink | bits::BranchIfGreater)
Operation(BranchIfEqualToRegisterAndLink,            GroupBranch | bits::RegisterBranch | bits::IsConditionalBranchAndLink | bits::BranchIfEqual)
Operation(BranchIfGreaterOrEqualToRegisterAndLink,   GroupBranch | bits::RegisterBranch | bits::IsConditionalBranchAndLink | bits::BranchIfGreaterOrEqual)
Operation(BranchIfLessToRegisterAndLink,             GroupBranch | bits::RegisterBranch | bits::IsConditionalBranchAndLink | bits::BranchIfLess)
Operation(BranchIfNotEqualToRegisterAndLink,         GroupBranch | bits::RegisterBranch | bits::IsConditionalBranchAndLink | bits::BranchIfNotEqual)
Operation(BranchIfLessOrEqualToRegisterAndLink,      GroupBranch | bits::RegisterBranch | bits::IsConditionalBranchAndLink | bits::BranchIfLessOrEqual)
Operation(BranchIfOrderedToRegisterAndLink,          GroupBranch | bits::RegisterBranch | bits::IsConditionalBranchAndLink | bits::BranchIfOrdered)
Operation(SelectIfUnordered,                         GroupBranch | bits::RegisterBranch | bits::IsSelectOperation | bits::BranchIfUnordered)
Operation(SelectIfGreater,                           GroupBranch | bits::RegisterBranch | bits::IsSelectOperation | bits::BranchIfGreater)
Operation(SelectIfEqual,                             GroupBranch | bits::RegisterBranch | bits::IsSelectOperation | bits::BranchIfEqual)
Operation(SelectIfGreaterOrEqual,                    GroupBranch | bits::RegisterBranch | bits::IsSelectOperation | bits::BranchIfGreaterOrEqual)
Operation(SelectIfLess,                              GroupBranch | bits::RegisterBranch | bits::IsSelectOperation | bits::BranchIfLess)
Operation(SelectIfNotEqual,                          GroupBranch | bits::RegisterBranch | bits::IsSelectOperation | bits::BranchIfNotEqual)
Operation(SelectIfLessOrEqual,                       GroupBranch | bits::RegisterBranch | bits::IsSelectOperation | bits::BranchIfLessOrEqual)
Operation(SelectIfOrdered,                           GroupBranch | bits::RegisterBranch | bits::IsSelectOperation | bits::BranchIfOrdered)
//-------------------------------------------------------------------------------------------------

#undef Operation
