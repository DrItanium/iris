/**
 * This file contains the binding between a given operation and its corresponding
 * format. Update this file when adding new type information
 */
// error is just zero and is not part of a group
// X(name, opcode)
#define Operation(name, opcode) X(name, (static_cast<EncodedInstruction>((opcode))))
//-------------------------------------------------------------------------------------------------
// Iris instructions are 32-bits wide and are carved up into four separate
// sections as follows:
// [0,  7] Argument2/Source2/Immediate8
// [8, 15] Argument1/Source1
// [16,23] Argument0/Destination
// [24,31] Opcode
// 
// With this design we can also merge Source2 and Source1 together to make a
// 16-bit immediate as well so we add this as well to the design:
// [0, 16] Immediate16

// Thus there are really a handful of forms with offshoots being degenerate
// cases. The forms are:
// 1) Three Register
// 1a) Two Register (Argument2 is 0)
// 1b) Two Register plus Imm8 (Argument2 does not refer to a register index)
// 2) One Register plus Imm16
// 2a) One Register (Imm16 is zero)
// 2b) Zero Register / Zero Argument (Argument0 and Imm16 are zero)
// 3) Imm24 (unused but theoretically possible)
//
// The rest of this file will describe the instructions and forms. Here are
// some other terms that may help if you are not familiar with them:
// 
// 1) Ordinal - Unsigned number
// 2) Integer - Signed number
//-------------------------------------------------------------------------------------------------
// The 8-bit opcode is divided generically into two parts:
// 0bMMMXXXXX
// where 0bMMM is the major opcode kind. There are a total of 8 major opcode
// groups with not all of the groups currently in use. The XXXXX portion is
// defined by the group to describe actions to perform under that major kind.
//
// The groups are:
// 0b000XXXXX - Arithmetic
// 0b001XXXXX - Compare
// 0b010XXXXX - Memory
// 0b011XXXXX - Branch Immediate
// 0b100XXXXX - Branch Register
// 0b101XXXXX - Bitwise
// 0b110XXXXX - Reserved for future use
// 0b111XXXXX - Reserved for future use
//-------------------------------------------------------------------------------------------------
// Arithmetic
// Arithmetic operations consist of:
// - Error
// - Add
// - Subtract
// - Multiply
// - Divide
// - Remainder
// - Shift Left
// - Shift Right
//
// With the exception of Error, the other arithmetic operations have integer
// and ordinal forms. This comes from the very elegantly designed i960
// processor.  
//-------------------------------------------------------------------------------------------------
/**
  * This is to make sure that a zero instruction is considered to be an error
  */
Operation(Error,                                     GroupArithmetic | bits::OperationError)
/**
  * Form: Three Register
  * Logic: reg[dest] = reg[src1] + reg[src2}
  */
Operation(AddOrdinal,                                GroupArithmetic | bits::OperationAdd | bits::KindOrdinal)
Operation(AddInteger,                                GroupArithmetic | bits::OperationAdd | bits::KindInteger)
/**
  * Form: Three Register
  * Logic: reg[dest] = reg[src1] - reg[src2]
  */
Operation(SubtractOrdinal,                           GroupArithmetic | bits::OperationSubtract | bits::KindOrdinal)
Operation(SubtractInteger,                           GroupArithmetic | bits::OperationSubtract | bits::KindInteger)
/**
  * Form: Three Register
  * Logic: reg[dest] = reg[src1] * reg[src2]
  */
Operation(MultiplyOrdinal,                           GroupArithmetic | bits::OperationMultiply | bits::KindOrdinal)
Operation(MultiplyInteger,                           GroupArithmetic | bits::OperationMultiply | bits::KindInteger)
/**
  * Form: Three Register
  * Logic: reg[dest] = reg[src1] / reg[src2]
  * NOTE: Will error if reg[src2] is zero
  */
Operation(DivideOrdinal,                             GroupArithmetic | bits::OperationDivide | bits::KindOrdinal)
Operation(DivideInteger,                             GroupArithmetic | bits::OperationDivide | bits::KindInteger)
/**
  * Form: Three Register
  * Logic: reg[dest] = reg[src1] % reg[src2]
  * NOTE: Will error if reg[src2] is zero
  */
Operation(RemainderOrdinal,                          GroupArithmetic | bits::OperationRemainder | bits::KindOrdinal)
Operation(RemainderInteger,                          GroupArithmetic | bits::OperationRemainder | bits::KindInteger)
/**
  * Form: Three Register
  * Logic: reg[dest] = (reg[src2] > 31) ? (reg[src1] << reg[src2]) : 0
  */

Operation(ShiftLeftOrdinal,                          GroupArithmetic | bits::OperationShiftLeft | bits::KindOrdinal)
Operation(ShiftLeftInteger,                          GroupArithmetic | bits::OperationShiftLeft | bits::KindInteger)
/**
  * Form: Three Register
  * Logic: reg[dest] = (reg[src2] > 31) ? (reg[src1] >> reg[src2]) : 0
  */
Operation(ShiftRightOrdinal,                         GroupArithmetic | bits::OperationShiftRight | bits::KindOrdinal)
Operation(ShiftRightInteger,                         GroupArithmetic | bits::OperationShiftRight | bits::KindInteger)
//-------------------------------------------------------------------------------------------------
Operation(BitwiseNot,                                GroupBitwise    | bits::OperationNot)
Operation(Move,                                      GroupBitwise    | bits::OperationNot | bits::NotTheResult)
Operation(LoadImmediate16,                           GroupBitwise    | bits::OperationNot | bits::NotTheResult | bits::ArgumentIsImm16)
Operation(BitwiseAnd,                                GroupBitwise    | bits::OperationAnd)
Operation(BitwiseNand,                               GroupBitwise    | bits::OperationAnd | bits::NotTheResult)
Operation(BitwiseOr,                                 GroupBitwise    | bits::OperationOr)
Operation(BitwiseNor,                                GroupBitwise    | bits::OperationOr | bits::NotTheResult)
Operation(BitwiseXor,                                GroupBitwise    | bits::OperationXor)
Operation(BitwiseXnor,                               GroupBitwise    | bits::OperationXor | bits::NotTheResult)
//-------------------------------------------------------------------------------------------------
Operation(CodeLoadWithOffset,                        GroupMemory     | bits::LoadOperation  | bits::Arg1IsRegister  | bits::SpaceCode) 
Operation(CodeLoadFromImmediateAddress,              GroupMemory     | bits::LoadOperation  | bits::Arg1IsImm       | bits::SpaceCode)
Operation(CodeStoreWithOffset,                       GroupMemory     | bits::StoreOperation | bits::Arg1IsRegister  | bits::SpaceCode)
Operation(CodeStoreToImmediateAddress,               GroupMemory     | bits::StoreOperation | bits::Arg1IsImm       | bits::SpaceCode)
Operation(DataLoadWithOffset,                        GroupMemory     | bits::LoadOperation  | bits::Arg1IsRegister  | bits::SpaceData)
Operation(DataLoadFromImmediateAddress,              GroupMemory     | bits::LoadOperation  | bits::Arg1IsImm       | bits::SpaceData)
Operation(DataStoreWithOffset,                       GroupMemory     | bits::StoreOperation | bits::Arg1IsRegister  | bits::SpaceData)
Operation(DataStoreToImmediateAddress,               GroupMemory     | bits::StoreOperation | bits::Arg1IsImm       | bits::SpaceData)
Operation(StackLoadWithOffset,                       GroupMemory     | bits::LoadOperation  | bits::Arg1IsRegister  | bits::SpaceStack)
Operation(StackLoadFromImmediateAddress,             GroupMemory     | bits::LoadOperation  | bits::Arg1IsImm       | bits::SpaceStack)
Operation(StackStoreWithOffset,                      GroupMemory     | bits::StoreOperation | bits::Arg1IsRegister  | bits::SpaceStack)
Operation(StackStoreToImmediateAddress,              GroupMemory     | bits::StoreOperation | bits::Arg1IsImm       | bits::SpaceStack)
Operation(IOLoadWithOffset,                          GroupMemory     | bits::LoadOperation  | bits::Arg1IsRegister  | bits::SpaceIO)
Operation(IOLoadFromImmediateAddress,                GroupMemory     | bits::LoadOperation  | bits::Arg1IsImm       | bits::SpaceIO)
Operation(IOStoreWithOffset,                         GroupMemory     | bits::StoreOperation | bits::Arg1IsRegister  | bits::SpaceIO)
Operation(IOStoreToImmediateAddress,                 GroupMemory     | bits::StoreOperation | bits::Arg1IsImm       | bits::SpaceIO)
//-------------------------------------------------------------------------------------------------
Operation(CompareOrdinal,                            GroupCompare    | bits::KindOrdinal)
Operation(CompareInteger,                            GroupCompare    | bits::KindInteger)
//-------------------------------------------------------------------------------------------------
// while these two opcodes are dumb, there may be a day where I can leverage this like the numerics architecture
// from i960 where branch if unordered will branch if an operation on reals yields an unordered number (NAN, etc)
Operation(BranchIfUnorderedToAbsoluteImmediate,      GroupBranchImm | bits::IsConditional | bits::AbsoluteJump | bits::BranchIfUnordered)
Operation(BranchIfUnorderedToRelativeImmediate,      GroupBranchImm | bits::IsConditional | bits::RelativeJump | bits::BranchIfUnordered)
Operation(BranchIfGreaterToAbsoluteImmediate,        GroupBranchImm | bits::IsConditional | bits::AbsoluteJump | bits::BranchIfGreater)
Operation(BranchIfGreaterToRelativeImmediate,        GroupBranchImm | bits::IsConditional | bits::RelativeJump | bits::BranchIfGreater)
Operation(BranchIfEqualToAbsoluteImmediate,          GroupBranchImm | bits::IsConditional | bits::AbsoluteJump | bits::BranchIfEqual)
Operation(BranchIfEqualToRelativeImmediate,          GroupBranchImm | bits::IsConditional | bits::RelativeJump | bits::BranchIfEqual)
Operation(BranchIfGreaterOrEqualToAbsoluteImmediate, GroupBranchImm | bits::IsConditional | bits::AbsoluteJump | bits::BranchIfGreaterOrEqual)
Operation(BranchIfGreaterOrEqualToRelativeImmediate, GroupBranchImm | bits::IsConditional | bits::RelativeJump | bits::BranchIfGreaterOrEqual)
Operation(BranchIfLessToAbsoluteImmediate,           GroupBranchImm | bits::IsConditional | bits::AbsoluteJump | bits::BranchIfLess)
Operation(BranchIfLessToRelativeImmediate,           GroupBranchImm | bits::IsConditional | bits::RelativeJump | bits::BranchIfLess)
Operation(BranchIfNotEqualToAbsoluteImmediate,       GroupBranchImm | bits::IsConditional | bits::AbsoluteJump | bits::BranchIfNotEqual)
Operation(BranchIfNotEqualToRelativeImmediate,       GroupBranchImm | bits::IsConditional | bits::RelativeJump | bits::BranchIfNotEqual)
Operation(BranchIfLessOrEqualToAbsoluteImmediate,    GroupBranchImm | bits::IsConditional | bits::AbsoluteJump | bits::BranchIfLessOrEqual)
Operation(BranchIfLessOrEqualToRelativeImmediate,    GroupBranchImm | bits::IsConditional | bits::RelativeJump | bits::BranchIfLessOrEqual)
Operation(BranchIfOrderedToAbsoluteImmediate,        GroupBranchImm | bits::IsConditional | bits::AbsoluteJump | bits::BranchIfOrdered)
Operation(BranchIfOrderedToRelativeImmediate,        GroupBranchImm | bits::IsConditional | bits::RelativeJump | bits::BranchIfOrdered)
Operation(BranchAbsoluteImmediateAndLink,            GroupBranchImm | bits::IsLink   | bits::AbsoluteJump)
Operation(BranchRelativeImmediateAndLink,            GroupBranchImm | bits::IsLink | bits::RelativeJump)
Operation(BranchIfUnorderedToRegisterAndLink,        GroupBranchReg | bits::IsConditionalBranchAndLink | bits::BranchIfUnordered)
Operation(BranchIfGreaterToRegisterAndLink,          GroupBranchReg | bits::IsConditionalBranchAndLink | bits::BranchIfGreater)
Operation(BranchIfEqualToRegisterAndLink,            GroupBranchReg | bits::IsConditionalBranchAndLink | bits::BranchIfEqual)
Operation(BranchIfGreaterOrEqualToRegisterAndLink,   GroupBranchReg | bits::IsConditionalBranchAndLink | bits::BranchIfGreaterOrEqual)
Operation(BranchIfLessToRegisterAndLink,             GroupBranchReg | bits::IsConditionalBranchAndLink | bits::BranchIfLess)
Operation(BranchIfNotEqualToRegisterAndLink,         GroupBranchReg | bits::IsConditionalBranchAndLink | bits::BranchIfNotEqual)
Operation(BranchIfLessOrEqualToRegisterAndLink,      GroupBranchReg | bits::IsConditionalBranchAndLink | bits::BranchIfLessOrEqual)
Operation(BranchIfOrderedToRegisterAndLink,          GroupBranchReg | bits::IsConditionalBranchAndLink | bits::BranchIfOrdered)
//-------------------------------------------------------------------------------------------------
Operation(SelectIfUnordered,                         GroupBranchReg | bits::IsSelectOperation | bits::BranchIfUnordered)
Operation(SelectIfGreater,                           GroupBranchReg | bits::IsSelectOperation | bits::BranchIfGreater)
Operation(SelectIfEqual,                             GroupBranchReg | bits::IsSelectOperation | bits::BranchIfEqual)
Operation(SelectIfGreaterOrEqual,                    GroupBranchReg | bits::IsSelectOperation | bits::BranchIfGreaterOrEqual)
Operation(SelectIfLess,                              GroupBranchReg | bits::IsSelectOperation | bits::BranchIfLess)
Operation(SelectIfNotEqual,                          GroupBranchReg | bits::IsSelectOperation | bits::BranchIfNotEqual)
Operation(SelectIfLessOrEqual,                       GroupBranchReg | bits::IsSelectOperation | bits::BranchIfLessOrEqual)
Operation(SelectIfOrdered,                           GroupBranchReg | bits::IsSelectOperation | bits::BranchIfOrdered)

#undef Operation
