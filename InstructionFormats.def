/**
 * This file contains the binding between a given operation and its corresponding
 * format. Update this file when adding new type information
 */
// error is just zero and is not part of a group
X(Error, ZeroArgument)
#define Instruction(group, op, Format) X(group ## op, Format)
#define Arithmetic(op, Format) Instruction(Arithmetic, op, Format)
#define ArithmeticSigned(op, Format) Arithmetic(op ## Signed, Format)
#define ArithmeticUnsigned(op, Format) Arithmetic(op ## Unsigned, Format)
#define ArithmeticSignedUnsigned(op, Format) \
    ArithmeticSigned(op, Format) \
    ArithmeticUnsigned(op, Format)
#define ArithmeticSignedImmediate(op) Arithmetic(op ## SignedImmediate, TwoRegisterS8)
#define ArithmeticUnsignedImmediate(op) Arithmetic(op ## UnsignedImmediate, TwoRegisterU8)
#define ArithmeticSignedUnsignedImmediate(op) \
        ArithmeticSignedImmediate(op) \
        ArithmeticUnsignedImmediate(op)
#define DoubleRegister(op, Format) Instruction(Arithmetic, Double ## op, Format)
#define DoubleRegisterSignedUnsigned(op, Format) \
        DoubleRegister(op ## Signed, Format) \
        DoubleRegister(op ## Unsigned, Format)
    ArithmeticSignedUnsigned(Add, ThreeRegister)
    ArithmeticSignedUnsigned(Subtract, ThreeRegister)
    ArithmeticSignedUnsigned(Multiply, ThreeRegister)
    ArithmeticSignedUnsigned(Divide, ThreeRegister)
    ArithmeticSignedUnsigned(Remainder, ThreeRegister)
    ArithmeticSignedUnsigned(ShiftLeft, ThreeRegister)
    ArithmeticSignedUnsigned(ShiftRight, ThreeRegister)
    ArithmeticSignedUnsigned(Max, ThreeRegister)
    ArithmeticSignedUnsigned(Min, ThreeRegister)
    Arithmetic(BitwiseNot, TwoRegister)
    Arithmetic(BitwiseAnd, ThreeRegister)
    Arithmetic(BitwiseOr, ThreeRegister)
    Arithmetic(BitwiseXor, ThreeRegister)
    Arithmetic(BitwiseNor, ThreeRegister)
    Arithmetic(BitwiseNand, ThreeRegister)
    // increment is adding one to register
    // decrement is subtracting one from the register
    ArithmeticSignedUnsignedImmediate(Add)
    ArithmeticSignedUnsignedImmediate(Subtract)
    // double is multiply by two or shift left by two
    ArithmeticSignedUnsignedImmediate(Multiply)
    // halve is divide by two or shift right by two imm
    ArithmeticSignedUnsignedImmediate(Divide)
    ArithmeticSignedUnsignedImmediate(Remainder)
    // double and triple can be defined in terms of this operation
    ArithmeticUnsignedImmediate(ShiftLeft)
    ArithmeticUnsignedImmediate(ShiftRight)
    // destructive direct operations can be simulated with multiple 
    // separate instructions
    DoubleRegister(BitwiseAnd, ThreeRegister)
    DoubleRegister(BitwiseOr, ThreeRegister)
    DoubleRegister(BitwiseNot, TwoRegister)
    DoubleRegister(BitwiseXor, ThreeRegister)
    DoubleRegister(BitwiseNor, ThreeRegister)
    DoubleRegister(BitwiseNand, ThreeRegister)
    DoubleRegisterSignedUnsigned(Add, ThreeRegister)
    DoubleRegisterSignedUnsigned(Subtract, ThreeRegister)
    DoubleRegisterSignedUnsigned(Multiply, ThreeRegister)
    DoubleRegisterSignedUnsigned(Divide, ThreeRegister)
    DoubleRegisterSignedUnsigned(Remainder, ThreeRegister)
    DoubleRegisterSignedUnsigned(ShiftLeft, ThreeRegister)
    DoubleRegisterSignedUnsigned(ShiftRight, ThreeRegister)
    DoubleRegisterSignedUnsigned(Min, ThreeRegister)
    DoubleRegisterSignedUnsigned(Max, ThreeRegister)
#undef DoubleRegisterSignedUnsigned
#undef DoubleRegister
#undef ArithmeticSignedImmediate
#undef ArithmeticUnsignedImmediate
#undef Arithmetic
#undef ArithmeticSigned
#undef ArithmeticUnsigned
#undef ArithmeticSignedUnsigned

#define Memory(op, Format) Instruction(Memory, op, Format)
#define Stack(op, Format) Memory(Stack ## op, Format)
#define Data(op, Format) Memory(Data ## op, Format)
#define Code(op, Format) Memory(Code ## op, Format)
#define IO(op, Format) Memory(IO ## op, Format)
    Memory(CopyRegister, TwoRegister)
    Memory(SwapRegisters, TwoRegister)
    Memory(AssignRegisterImmediate, OneRegisterU16)
    // signed version is very easy to emulate in an assembler
    Stack(Push, TwoRegister)
    Stack(Pop, TwoRegister)
    Stack(PushImmediateValue, OneRegisterU16)
    // So when dealing with data operations we have some interesting stuff to think about
    // - There is always an offset that can either be a register or immediate
    // - Because it can be register or immediate offset, there will need to be 
    //   multiple forms of each instruction
    // - Code modifications do not take offsets into account, however an increment
    //   can happen automatically as part of the load store operation as well
    // - Offsets can either be signed or unsigned
    // 
    // Other notes:
    // DataStoreImmediateValue stores an imm16 at the given target address in data space
    // IOStoreImmediateValue stores an imm16 at the given target address in IO space
    Data(LoadWithOffset, TwoRegisterU8)
    Data(StoreWithOffset, TwoRegisterU8)
    Data(StoreImmediateValue, OneRegisterU16)
    Code(LoadWithOffset, TwoRegisterU8)
    Code(StoreWithOffset, TwoRegisterU8)
    Code(LoadAndIncrement, TwoRegisterU8)
    Code(StoreAndIncrement, TwoRegisterU8)
    Code(LoadAndDecrement, TwoRegisterU8)
    Code(StoreAndDecrement, TwoRegisterU8)

    IO(LoadWithOffset, TwoRegisterU8)
    IO(StoreWithOffset, TwoRegisterU8)
    IO(StoreImmediateValue, OneRegisterU16)
    Memory(MoveFromIP, OneRegister)
    Memory(MoveToIP, OneRegister)
    Memory(DoubleDataLoadWithOffset, TwoRegisterU8)
    Memory(DoubleDataStoreWithOffset, TwoRegisterU8)
    Memory(DoubleIOLoadWithOffset, TwoRegisterU8)
    Memory(DoubleIOStoreWithOffset, TwoRegisterU8)
    Memory(QuadCodeStoreWithOffset, TwoRegisterU8)
    Memory(QuadCodeLoadWithOffset, TwoRegisterU8)
    Memory(QuadDataStoreWithOffset, TwoRegisterU8)
    Memory(QuadDataLoadWithOffset, TwoRegisterU8)
    Memory(QuadIOStoreWithOffset, TwoRegisterU8)
    Memory(QuadIOLoadWithOffset, TwoRegisterU8)
#undef Stack
#undef Data
#undef Code
#undef IO
#undef Memory

#define Branch(op, Format) Instruction(Branch, op, Format)
    Branch(Immediate, U16)
    Branch(ConditionalImmediate, OneRegisterU16)
    Branch(RelativeImmediate, S8)
    Branch(ConditionalRelativeImmediate, OneRegisterS8)
    Branch(Register, OneRegister)
    Branch(ConditionalRegister, TwoRegister)
    Branch(RegisterAndLink, TwoRegister)
    Branch(ImmediateAndLink, OneRegisterU16)
    Branch(ConditionalRegisterAndLink, ThreeRegister)
    Branch(Select, ThreeRegister)
#undef Branch
#define Compare(op, Format) Instruction(Compare, op, Format)
#define NormalCompare(op) Compare(op, ThreeRegister)
#define NormalSignedCompare(op) NormalCompare(op ## Signed)
#define NormalUnsignedCompare(op) NormalCompare(op ## Unsigned)
#define NormalSignedUnsignedCompare(op) \
        NormalSignedCompare(op) \
        NormalUnsignedCompare(op)
#define RawImm8Compare(op, Format) Compare(op ## Immediate8, Format)
#define Imm8Compare(op) RawImm8Compare(op, TwoRegisterU8)
#define Imm8SignedCompare(op) RawImm8Compare(op ## Signed , TwoRegisterS8)
#define Imm8UnsignedCompare(op) Imm8Compare(op ## Unsigned)
#define Imm8SignedUnsignedCompare(op) \
        Imm8SignedCompare(op) \
        Imm8UnsignedCompare(op)
    NormalCompare(Equals)
    NormalCompare(NotEquals)
    NormalSignedUnsignedCompare(LessThan)
    NormalSignedUnsignedCompare(GreaterThan)
    NormalSignedUnsignedCompare(LessThanOrEqualTo)
    NormalSignedUnsignedCompare(GreaterThanOrEqualTo)
    //NormalSignedUnsignedCompare(Spaceship)
    Imm8Compare(Equals)
    Imm8Compare(NotEquals)
    Imm8SignedUnsignedCompare(LessThan)
    Imm8SignedUnsignedCompare(GreaterThan)
    Imm8SignedUnsignedCompare(LessThanOrEqualTo)
    Imm8SignedUnsignedCompare(GreaterThanOrEqualTo)
    //Imm8SignedUnsignedCompare(Spaceship)

#undef NormalSignedCompare
#undef NormalUnsignedCompare 
#undef NormalCompare
#undef NormalSignedUnsignedCompare
#undef Imm8SignedUnsignedCompare
#undef RawImm8Compare
#undef Imm8Compare
#undef Imm8SignedCompare
#undef Imm8UnsignedCompare

#undef Compare
#undef Instruction

