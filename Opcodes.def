FirstX(Add, ThreeRegister, add)
X(Sub, ThreeRegister, sub)
X(Mul, ThreeRegister, mul)
X(Div, ThreeRegister, div)
X(Rem, ThreeRegister, rem)
X(ShiftLeft, ThreeRegister, shl)
X(ShiftRight, ThreeRegister, shr)
X(And, ThreeRegister, and)
X(Or, ThreeRegister, or)
X(Not, TwoRegister, not)
X(Xor, ThreeRegister, xor)
X(Nand, ThreeRegister, nand)
X(Nor, ThreeRegister, nor)
X(Min, ThreeRegister, min)
X(Max, ThreeRegister, max)
X(Eq, ThreeRegister, eq)
X(Neq, ThreeRegister, neq)
X(LessThan, ThreeRegister, lt)
X(GreaterThan, ThreeRegister, gt)
X(LessThanOrEqualTo, ThreeRegister, le)
X(GreaterThanOrEqualTo, ThreeRegister, ge)
X(Set, OneRegisterWithImmediate, set)
X(Load, TwoRegister, ld)
X(Store, TwoRegister, st)
X(Push, TwoRegister, push)
X(Pop, TwoRegister, pop)
X(LoadCore, TwoRegister, ldc)
X(StoreCore, TwoRegister, stc)
X(LoadIO, TwoRegister, ldio)
X(StoreIO, TwoRegister, stio)
// branch operations
X(BranchRegister, OneRegister, br)
X(BranchRegisterAndLink, TwoRegister, brl)
X(BranchConditionalRegister, TwoRegister, bcr)
X(BranchConditionalRegisterLink, ThreeRegister, bcrl)
// misc
// Push eight registers onto the stack at a time given the provided bit pattern
// uses the 16-bit constant like so:
// 0bRRRRRRRR000GGGGG 
// where:
//   G is the bit pattern denoting which group of eight registers to push/pop
//   R is the bit pattern denoting which of the eight registers in the group
//     to push/pop onto/off the stack
//
// The group bits define which register to start with, it is shifted by three
// internally to determine the base offset
// The registers are pushed onto the stack of lowest to highest within the 
// group. If a given bit pattern does not allow a for a given register to be pushed
// then it is skipped
//
// Registers are popped off the stack from higest to lowest to compliment the 
// the behavior of push-group
//
// If the pattern zero is found in RRRRRRRRR then nothing happens
X(UnsignedEq, ThreeRegister, equ)
X(UnsignedNeq, ThreeRegister, nequ)
X(UnsignedLessThan, ThreeRegister, ltu)
X(UnsignedGreaterThan, ThreeRegister, gtu)
X(UnsignedLessThanOrEqualTo, ThreeRegister, leu)
X(UnsignedGreaterThanOrEqualTo, ThreeRegister, geu)
X(UnsignedAnd, ThreeRegister, andu)
X(UnsignedOr, ThreeRegister, oru)
X(UnsignedNot, TwoRegister, notu)
X(UnsignedXor, ThreeRegister, xoru)
X(UnsignedNand, ThreeRegister, nandu)
X(UnsignedNor, ThreeRegister, noru)
X(UnsignedMin, ThreeRegister, minu)
X(UnsignedMax, ThreeRegister, maxu)
X(UnsignedAdd, ThreeRegister, addu)
X(UnsignedSub, ThreeRegister, subu)
X(UnsignedMul, ThreeRegister, mulu)
X(UnsignedDiv, ThreeRegister, divu)
X(UnsignedRem, ThreeRegister, remu)
X(UnsignedShiftLeft, ThreeRegister, shlu)
X(UnsignedShiftRight, ThreeRegister, shru)

// "microcode" routines for making the forth interpreter implementation
// faster
// routines from Threaded Interpretive Languages as well
// X(ReadToken, TwoRegister, readtok)
// X(NumberRoutine, ThreeRegister, number-routine)
X(Increment, TwoRegister, incr)
X(Decrement, TwoRegister, decr)
X(UnsignedIncrement, TwoRegister, uincr)
X(UnsignedDecrement, TwoRegister, udecr)
X(Call, OneRegisterWithImmediate, call)
X(ConditionalBranch, OneRegisterWithImmediate, bc)
X(AddImmediate, TwoRegisterWithImmediate, addi)
X(SubImmediate, TwoRegisterWithImmediate, subi)
X(RightShiftImmediate, TwoRegisterWithImmediate, rshifti)
X(LeftShiftImmediate, TwoRegisterWithImmediate, lshifti)
X(LoadThenIncrement, TwoRegister, ldtincr)
X(LessThanImmediate, TwoRegisterWithImmediate, lti)
X(Move, TwoRegister, move)
// dest src dest2 src2
X(Move2, FourRegister, move2)
