FirstX(Illegal, ThreeRegister, illegal) // prevent errant execution
X(Add, ThreeRegister, add)
X(Sub, ThreeRegister, sub)
X(Mul, ThreeRegister, mul)
X(Div, ThreeRegister, div)
X(Rem, ThreeRegister, rem)
X(ShiftLeft, ThreeRegister, shl)
X(ShiftRight, ThreeRegister, shr)
X(And, ThreeRegister, and)
X(Or, ThreeRegister, or)
X(Not, TwoRegister, not)
X(Xor, ThreeRegister, xor)
X(Nand, ThreeRegister, nand)
X(Nor, ThreeRegister, nor)
X(Min, ThreeRegister, min)
X(Max, ThreeRegister, max)
X(Eq, ThreeRegister, eq)
X(Neq, ThreeRegister, neq)
X(LessThan, ThreeRegister, lt)
X(GreaterThan, ThreeRegister, gt)
X(LessThanOrEqualTo, ThreeRegister, le)
X(GreaterThanOrEqualTo, ThreeRegister, ge)
X(Set, OneRegisterWithImmediate, set)
X(Load, TwoRegister, ld)
X(Store, TwoRegister, st)
X(Push, TwoRegister, push) // decrement dest and then store src into it
X(Pop, TwoRegister, pop) // increment src and then load into dest
X(BranchRegister, OneRegister, br)
X(BranchRegisterAndLink, TwoRegister, brl)
X(BranchConditionalRegister, TwoRegister, bcr)
X(BranchConditionalRegisterLink, ThreeRegister, bcrl)
X(UnsignedEq, ThreeRegister, equ)
X(UnsignedNeq, ThreeRegister, nequ)
X(UnsignedLessThan, ThreeRegister, ltu)
X(UnsignedGreaterThan, ThreeRegister, gtu)
X(UnsignedLessThanOrEqualTo, ThreeRegister, leu)
X(UnsignedGreaterThanOrEqualTo, ThreeRegister, geu)
X(UnsignedAnd, ThreeRegister, andu)
X(UnsignedOr, ThreeRegister, oru)
X(UnsignedNot, TwoRegister, notu)
X(UnsignedXor, ThreeRegister, xoru)
X(UnsignedNand, ThreeRegister, nandu)
X(UnsignedNor, ThreeRegister, noru)
X(UnsignedMin, ThreeRegister, minu)
X(UnsignedMax, ThreeRegister, maxu)
X(UnsignedAdd, ThreeRegister, addu)
X(UnsignedSub, ThreeRegister, subu)
X(UnsignedMul, ThreeRegister, mulu)
X(UnsignedDiv, ThreeRegister, divu)
X(UnsignedRem, ThreeRegister, remu)
X(UnsignedShiftLeft, ThreeRegister, shlu)
X(UnsignedShiftRight, ThreeRegister, shru)
X(Increment, TwoRegister, incr)
X(Decrement, TwoRegister, decr)
X(UnsignedIncrement, TwoRegister, uincr)
X(UnsignedDecrement, TwoRegister, udecr)
X(Call, OneRegisterWithImmediate, call)
X(ConditionalBranch, OneRegisterWithImmediate, bc)
X(AddImmediate, TwoRegisterWithImmediate, addi)
X(SubImmediate, TwoRegisterWithImmediate, subi)
X(RightShiftImmediate, TwoRegisterWithImmediate, rshifti)
X(LeftShiftImmediate, TwoRegisterWithImmediate, lshifti)
X(LoadThenIncrement, TwoRegister, ldtincr)
X(LessThanImmediate, TwoRegisterWithImmediate, lti)
X(Move, TwoRegister, move)
X(StoreThenIncrement, TwoRegister, sttincr)
X(ReadLine, TwoRegister, wltm) // write a line from stdin into memory
							   // dest - address to write to (length is written
							   // into the first cell)
							   // src - maximum length
X(PrintOK, NoArguments, prok) // print ok
X(Digit, FourRegister, digit) // convert the provided character in src3 with
	                          // base n1 to a binary number n2 with a true flag
							  // on top of stack. If the digit is an invalid
							  // character, only a false flagis left on stack.
							  // ( c n1 -- n2 tf or ff )
							  // src3 - character to convert
							  // src2 - number base
							  // src - number
							  // dest - success flag
X(Enclose, OneRegister, enclose) 
	// A primitive word to scan the text. From the byte address and the
	// delimiter c, it determines the byte offset to the first non-delimiter
	// character, the offset to the first delimiter after the text string, and
	// the offset to the next character after the delimiter. If the string is
	// delimited by a nul, the last offset is equal  to the previous offset
	// dest - stack pointer to grab arguments from
	// ( addr c -- addr nl n2 n3 )

