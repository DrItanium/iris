FirstX(Illegal, ThreeRegister, illegal) // prevent errant execution
X(Add, ThreeRegister, add)
X(Sub, ThreeRegister, sub)
X(Mul, ThreeRegister, mul)
X(Div, ThreeRegister, div)
X(Rem, ThreeRegister, rem)
X(ShiftLeft, ThreeRegister, shl)
X(ShiftRight, ThreeRegister, shr)
X(And, ThreeRegister, and)
X(Or, ThreeRegister, or)
X(Not, TwoRegister, not)
X(Xor, ThreeRegister, xor)
X(Nand, ThreeRegister, nand)
X(Nor, ThreeRegister, nor)
X(Min, ThreeRegister, min)
X(Max, ThreeRegister, max)
X(Eq, ThreeRegister, eq)
X(Neq, ThreeRegister, neq)
X(LessThan, ThreeRegister, lt)
X(GreaterThan, ThreeRegister, gt)
X(LessThanOrEqualTo, ThreeRegister, le)
X(GreaterThanOrEqualTo, ThreeRegister, ge)
X(Set, OneRegisterWithImmediate, set)
X(Load, TwoRegister, ld)
X(Store, TwoRegister, st)
X(Push, TwoRegister, push) // decrement dest and then store src into it
X(Pop, TwoRegister, pop) // increment src and then load into dest
X(BranchRegister, OneRegister, br)
X(BranchRegisterAndLink, TwoRegister, brl)
X(BranchConditionalRegister, TwoRegister, bcr)
X(BranchConditionalRegisterLink, ThreeRegister, bcrl)
X(UnsignedEq, ThreeRegister, equ)
X(UnsignedNeq, ThreeRegister, nequ)
X(UnsignedLessThan, ThreeRegister, ltu)
X(UnsignedGreaterThan, ThreeRegister, gtu)
X(UnsignedLessThanOrEqualTo, ThreeRegister, leu)
X(UnsignedGreaterThanOrEqualTo, ThreeRegister, geu)
X(UnsignedAnd, ThreeRegister, andu)
X(UnsignedOr, ThreeRegister, oru)
X(UnsignedNot, TwoRegister, notu)
X(UnsignedXor, ThreeRegister, xoru)
X(UnsignedNand, ThreeRegister, nandu)
X(UnsignedNor, ThreeRegister, noru)
X(UnsignedMin, ThreeRegister, minu)
X(UnsignedMax, ThreeRegister, maxu)
X(UnsignedAdd, ThreeRegister, addu)
X(UnsignedSub, ThreeRegister, subu)
X(UnsignedMul, ThreeRegister, mulu)
X(UnsignedDiv, ThreeRegister, divu)
X(UnsignedRem, ThreeRegister, remu)
X(UnsignedShiftLeft, ThreeRegister, shlu)
X(UnsignedShiftRight, ThreeRegister, shru)
X(Increment, TwoRegister, incr)
X(Decrement, TwoRegister, decr)
X(UnsignedIncrement, TwoRegister, uincr)
X(UnsignedDecrement, TwoRegister, udecr)
X(Call, OneRegisterWithImmediate, call)
X(ConditionalBranch, OneRegisterWithImmediate, bc)
X(AddImmediate, TwoRegisterWithImmediate, addi)
X(SubImmediate, TwoRegisterWithImmediate, subi)
X(RightShiftImmediate, TwoRegisterWithImmediate, rshifti)
X(LeftShiftImmediate, TwoRegisterWithImmediate, lshifti)
X(LoadThenIncrement, TwoRegister, ldtincr)
X(LessThanImmediate, TwoRegisterWithImmediate, lti)
X(Move, TwoRegister, move)
X(StoreThenIncrement, TwoRegister, sttincr)
X(ReadLine, TwoRegister, wltm) // write a line from stdin into memory
							   // dest - address to write to (length is written
							   // into the first cell)
							   // src - maximum length
X(PrintOK, NoArguments, prok) // print ok
X(Digit, FourRegister, digit) // convert the provided character in src3 with
	                          // base n1 to a binary number n2 with a true flag
							  // on top of stack. If the digit is an invalid
							  // character, only a false flagis left on stack.
							  // ( c n1 -- n2 tf or ff )
							  // src3 - character to convert
							  // src2 - number base
							  // src - number
							  // dest - success flag
