FirstX(Illegal, NoArguments) // prevent errant execution
X(Add, ThreeRegister)
X(Sub, ThreeRegister)
X(Mul, ThreeRegister)
X(Div, ThreeRegister)
X(Rem, ThreeRegister)
X(ShiftLeft, ThreeRegister)
X(ShiftRight, ThreeRegister)
X(And, ThreeRegister)
X(Or, ThreeRegister)
X(Not, TwoRegister)
X(Xor, ThreeRegister)
X(Nand, ThreeRegister)
X(Nor, ThreeRegister)
X(Min, ThreeRegister)
X(Max, ThreeRegister)
X(Eq, ThreeRegister)
X(Neq, ThreeRegister)
X(LessThan, ThreeRegister)
X(GreaterThan, ThreeRegister)
X(LessThanOrEqualTo, ThreeRegister)
X(GreaterThanOrEqualTo, ThreeRegister)
X(Set, OneRegisterWithImmediate)
X(Load, TwoRegister)
X(Store, TwoRegister)
X(Push, TwoRegister) // decrement dest and then store src into it
X(Pop, TwoRegister) // increment src and then load into dest
X(BranchRegister, OneRegister)
X(BranchRegisterAndLink, TwoRegister)
X(BranchConditionalRegister, TwoRegister)
X(BranchConditionalRegisterLink, ThreeRegister)
X(UnsignedEq, ThreeRegister)
X(UnsignedNeq, ThreeRegister)
X(UnsignedLessThan, ThreeRegister)
X(UnsignedGreaterThan, ThreeRegister)
X(UnsignedLessThanOrEqualTo, ThreeRegister)
X(UnsignedGreaterThanOrEqualTo, ThreeRegister)
X(UnsignedAnd, ThreeRegister)
X(UnsignedOr, ThreeRegister)
X(UnsignedNot, TwoRegister)
X(UnsignedXor, ThreeRegister)
X(UnsignedNand, ThreeRegister)
X(UnsignedNor, ThreeRegister)
X(UnsignedMin, ThreeRegister)
X(UnsignedMax, ThreeRegister)
X(UnsignedAdd, ThreeRegister)
X(UnsignedSub, ThreeRegister)
X(UnsignedMul, ThreeRegister)
X(UnsignedDiv, ThreeRegister)
X(UnsignedRem, ThreeRegister)
X(UnsignedShiftLeft, ThreeRegister)
X(UnsignedShiftRight, ThreeRegister)
X(Increment, TwoRegister)
X(Decrement, TwoRegister)
X(UnsignedIncrement, TwoRegister)
X(UnsignedDecrement, TwoRegister)
X(Call, OneRegisterWithImmediate)
X(ConditionalBranch, OneRegisterWithImmediate)
X(AddImmediate, TwoRegisterWithImmediate)
X(SubImmediate, TwoRegisterWithImmediate)
X(RightShiftImmediate, TwoRegisterWithImmediate)
X(LeftShiftImmediate, TwoRegisterWithImmediate)
X(LoadThenIncrement, TwoRegister)
X(LessThanImmediate, TwoRegisterWithImmediate)
X(Move, TwoRegister)
X(StoreThenIncrement, TwoRegister)
// forth operations
X(ReadLine, TwoRegister) // write a line from stdin into memory
							   // dest - address to write to (length is written
							   // into the first cell)
							   // src - maximum length
X(PrintOK, NoArguments) // print ok
X(Digit, OneRegister) // convert the provided character in src3 with
	                          // base n1 to a binary number n2 with a true flag
							  // on top of stack. If the digit is an invalid
							  // character, only a false flagis left on stack.
							  // ( c n1 -- n2 tf or ff )
X(Enclose, OneRegister) 
	// A primitive word to scan the text. From the byte address and the
	// delimiter c, it determines the byte offset to the first non-delimiter
	// character, the offset to the first delimiter after the text string, and
	// the offset to the next character after the delimiter. If the string is
	// delimited by a nul, the last offset is equal  to the previous offset
	// dest - stack pointer to grab arguments from
	// ( addr c -- addr nl n2 n3 )
X(PrimitiveFind, OneRegister) 
    // searches the dictionary starting at the name field address addr2
    // matching to the text at addr1. Returns parameter field address and
    // boolean true for a good match
    //
    // No match only pushes false to the stack
    // ( addr1 addr2 -- pfa tf ) ( ok )
    // ( addr1 addr2 -- ff ) ( bad )
X(WideAdd, ThreeRegister)
X(WideSubtract, ThreeRegister)
X(WidePush, TwoRegister)
X(WidePop, TwoRegister)
