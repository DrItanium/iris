Power PC as a Forth Engine

C. H. Ting


1.	Introduction

PowerPC architecture was developed in IBM for the mainframe computers and the
personal computers.  It was adopted by Apple to run in the newer Macintosh
computers, and was also manufactured by Motorola.  In the brief time I worked
at the UMAX Computer Corp, I was given the opportunity to study the
OpenFirmware system which boots the Macintosh OS system, and also evaluate the
Forth code development environment, which compiles the OpenFirmware and
generates a target image for the boot ROM.  I found that PowerPC is an
interesting chip and serves very well as a Forth engine.

Apple chose to use Wil Baden's ThisForth as the Forth code develop environment,
mainly because ThisForth is a public domain Forth system and also because it
was written in C and was easily ported over to the Macintosh-PowerPC system.
However, most of the code in ThisForth was produced by the PDM4 macro language,
which is very cryptic, and nobody knows how to maintain it.  UMAX was quite
ambitious in deciding to build its own Forth environment to replace ThisForth.

I took the 32-bit 386 eForth and ported it to Macintosh Programmer Workshop,
which is the standard software development system provided by Apple.  It has C
and C++ compilers, PowerPC assembler, debugger, and all the tools for software
development.  I first brought up the  elementary eForth system with the small
machine dependent kernel, as Version 1.01.  Later, I enhanced the system by
replacing all the tool words by PowerPC code, and added all the utilities
ThisForth provided.  The latest version was 2.07, just before UMAX laid off all
the Mac programmers, thanks to Mr. Steve Jobs' decision to close down all the
Mac clone shops.

PowerPC eForth version 2.07 is quite powerful and very fast.  It includes all
the functionality of ThisForth and many of the features required to compile
PowerPC OpenFirmware.  However, the closing of the UMAX firmware group was so
sudden that I didn't have time to really exercise it in compiling OpenFirmware.
I had test-compiled most of the OpenFirmeare system, but didn't try to part
which produces the ROM image.  Maybe a couple of weeks would be sufficient to
complete the task.

In this paper I will discuss the implementation of eForth on PowerPC chip and
show that PowerPC is a very nice host for Forth, in spite of the fact that it
is not a stack machine.

2.	Forth Virtual Engine on Power PC

The register assignments are:

Name    PPC Register   Function
----------------------------------------
rTOS    r20            Top of data stack 
rNOS    r21            Next of data stack 
rDP     r31            Data stack pointer 
rLR     r18            Shadow of link register 
rTOR    r19            Top of return stack 
rRP     r30            Return stack pointer 
rBase   r25            Base address for relocation 
rUP     r29            User area pointer 
t1:     r13            scratch pad registers 
t2:     r14            scratch pad registers

Being a RISC machine, PowerPC does not have CALL and RET instructions.
Instead, the Branch-Link (BL) instruction saves the address of the next
instruction in the Link Register (LR), and the Branch-Thru-Link (BLR)
instruction returns to this location after the subroutine is completed.  The
address field in the BL instruction is 26 bits wide, and is quite adequate to
reach the entire dictionary space in the relative addressing mode.

It we consider the BL instruction as a CALL with a one level return stack, we
can use the Subroutine-Threaded-Model to implement Forth on PowerPC.  Thus in
the list of a colon definition, all the token in the list are BL  instructions
of Power PC microprocessor.  NEXT is thus a single machine instruction BLR.  In
this sense, PowerPC is a Forth engine.

The LR register in PPC branch processor is thus the IP register of the eForth
virtual machine.

One important advantage of the Subroutine-Thread-Model is that the tokens in
the colon definitions are machine instructions, and consequently one can mix
other machine instructions in-line with the tokens.  This feature allows Forth
words to be easily optimized by inserting machine code directly into colon
definitions.

3.	Stack Cache

To implement the data stack and the return stack, we need at least two CPU
registers as stack pointers.  Here we use r31 is the stack pointer and r30 as
the return stack pointer.  As PowerPC has 32 registers in the Integer ALU unit,
much more than what is required in a minimal Forth virtual machine, we have the
freedom of using other registers to enhance the performance of PowerPC as a
Forth engine.

Both the top of the data stack (rTOS) and the top of the return stack (rTOR)
are cached in CPU registers: r20 and r19.  r21 is used to hold temporarily the
contents of the next item on the data stack as rNOS.  Having the top stack
items cached in CPU registers optimizes the performance of the Forth Virtual
Engine and reduces the stack pushing and popping of stacks in run-time.

To access stack items, PowerPC can post-increment or post-decrement the stack
pointer register in a single memory accessing instruction.  However, it cannot
pre-increment of pre-decrement.  It is thus only half of a good stack machine.
I choose to post-decrement the stack pointer on pushing.  On popping, the stack
pointer has to be incremented before doing memory read or write.

4.	Memory Addressing

The Forth Engine accesses memory using addresses relative to the origin of the
eForth image in memory.  The absolute address of the origin is stored in rBase
register (r25).  Therefore, this eForth is totally relocatable, because all the
tokens in the list of colon words are relative branch-link instructions with
26-bit address offsets in the address fields.

Upon entering into a colon words, the address pushed on the return stack is an
absolute address.  Addresses of data visible to the eForth system are relative
addresses from the origin of eForth as placed in the memory.  The absolute
address of the origin is stored in register rBase.  When coding in assembly,
you have to be aware of the two distinct addressing systems.  Normal Forth
operations assumes the relative addresses.  Only when you pop address back from
the return stack, you have to convert the absolute address to relative address
before you can you @ or ! to access the memory.

Relative address has the advantage of relocation.  eForth thus can be loaded
into any memory region and the code will run without any modification.

5.	OS Interface

eForth is entered via a small C program, which posts a sign-on message and then
calls eForth as a subroutine.  This C calling program is very useful in
developing the Forth words which must request services from the operating
system.  These Forth functions were first written in C, tested, and then the
functions were recoded in Forth.

The only input/output functions eForth need are the terminal input ?RX and
terminal output TX!.  eForth only assumes one serial port for user interaction.
KEY and EMIT are vectored through ?RX and TX! to get characters from the user
and display characters on the appropriate display device.  In PPC eForth, ?RX
calls 'read' to get characters from the Mac OS, and TX! calls 'write' to send
characters to the Mac OS.  This scheme works fine under MPW. 

The C program CALLING.C is compile by the C compiler MRC and then linked with
the eForth program for execution.  CAALING.C is my playground to test many
different OS interface like files, time/date, memory allocation, etc.

6.	File Interface

The most important file related function in eForth is the loading of source
files.  It is desirable to be able to load files from other files, recursively,
and without limits on the number of files to be loaded and the levels of file
loading.  The operating system generally allows an application to open many
files, and each file is associated with a file handle.  I found that with a
very simple mechanism, one can achieved these goals.  This mechanism was
implemented in the MIPS eForth. and was ported over to PowerPC eForth.

The mechanism is to make the terminal input buffer as large as possible.  The
INCLUDE commands opens a file, loads the source at the end of the text in the
terminal buffer, and then closes the file immediately.  The source text of the
file is interpreted.  When the entire text of the file is processed, the
interpreter continues to process the text received from the terminal.

If we encounter another INCLUDE command in the file, the new file is opened and
loaded at the end of the old file.  The new file is closed and its text is
interpreted.  After the new file is finished, the rest of the old file is
interpreted from the point after the INCLUDE command.  Files can thus be loaded
recursively, as long as the terminal input buffer is large enough to hold all
the files for interpreting.  If we structure the loading process by loading all
the files from one file, the terminal input buffer needs only to be big enough
to hold the loading file and the largest of the loaded files.

7.	Debugging

Macintosh has a powerful debugging tool MacsBug.  It is invoked whenever an
illegal instruction is executed or when some system errors occur.  It is smart
enough to know when to enter the PowerPC mod or the 68000 mode.  In the PowerPC
mode, you can see the contends of all the CPU registers, and can inspect
memory, change memory, disassemble PowerPC machine instructions, setting break
points, and single stepping through code anywhere in the memory.  It was my
best friend when I brought the eForth system up.

PPC eForth provides several entry points to the code image for the convenience
of debugging the system when there is trouble.  The entry point DEBUG has an
invalid PPC instruction, which will trap to Macsbug.  Set PC to 4 bytes passing
DEBUG will start eForth under Macsbug.  There you can use the full suite of
Macbug commands to debug eForth and its applications.

The command:

    0  EXECUTE

will invoke the Macsbug and then you can debug the application using Macsbug.

8.	Local Variables

Local variables are conveniences for people who hate stacks.  OpenFirmware uses
local variables extensively, and I have to implement them according to the
OpenFirmware style.  The syntax of local variables is:

    :  <name>  {  ...  stack3 stack2 stack1 ; local1 local2 local3 ... }
    <ForthWordList> ;

Inside the curly brackets, items before semi-colon are input parameters taken
from the data stack; and items after the semi-colon are names of local
variable.  Stack items and local items can be referred in <ForthWordList> by
names to get their values on to the data stack.  The TO command is used to
store new values into the stack or local items.  Input stack items are removed
from the data stack and stored into local variable.  Items left on the data
stack are the stack output from this word.  In a word, up to 10 local variables
are allowed.  

Local variables are expensive, no matter how they are implemented.  In this
implementation, a special register is designated as the local variable frame
pointer, and a fairly large memory area must be allocated for the local
variable frames.  Local variable frames are stacked up during execution.  Each
word with local variables must push a local variable frame, move the stack
input items to the frame, read values from the frame, store new values into the
frame, and finally must pop the frame.

Only after implementing the local variables, one can appreciate the simplicity
of Forth in passing all parameters through a single stack.

9.	ANS Forth Standard

I tried to build this PowerPC eForth aligned to ANS Forth Standard.  However,
the primary objective was to replace ThisForth and standard compliance was not
pursued with vengeance.  All words with standard names have standard behavior,
but not all the standard and extension words were implemented.

10.	Executable Structures

OpenFirmware has an interesting feature that most control and loop structures
can be interpreted as well as compiled in colon words.  The structure building
words like IF, ELSE, THEN, BEGIN, UNTIL, DO, and LOOP are smart so that when
they are invoked while interpreting, they build the necessary structures in a
small buffer.  These structures are executed and then forgotten.

I was very interested in the interpreting of structures, to the point that I
tried to discard the interpreter completely.  In version 2.05, everything is
compiled.  After a line of commands is accepted, the commands are compiled into
a command buffer as a new colon word, only without an header.  A DOCOL starts
the buffer and an EXIT is attached to the end of the buffer.  This headerless
word is executed and the buffer is used to compile the next line of commands
from the keyboard.

Since all commands are compiled, all the structures are compiled and not
special attention is necessary for interpreting structures.

This scheme works well in most cases.  The only problem is CREATE.  Here all
the defining words must be IMMEDIATE, because they have to build new words and
cannot be themselves compiled into colon words.  The problem with CREATE is
that when we have to define a defining word, CREATE must be compiled into the
definition of the defining word.  Its immediate behavior has to be POSTPONEd to
the time when the defining word is executed.

Defining words were used very extensively in OpenFirmware, and it was
inappropriate for me the change all the source code to postpone CREATE.
Eventually, I abandoned the compiler-only approach and dutifully implemented
the smart control words so that we can interpret the control structures.

11.	Benchmark

I tested the eForth against the ThisForth.  Timing for the two systems on the
following testing routines are:

Test Routines							 ThisForth (sec)      eForth 	:
LOOPTEST 10000000 0 DO LOOP ;				4		1 : +TEST    10000000 0 DO
R@ DUP + DROP LOOP ;		11		2 : *TEST    10000000 0 DO R@ DUP * DROP
LOOP ;		11		2 : /TEST    10000000 0 DO 10000000 R@ / DROP LOOP ;
12		3

eForth is about 4-5 times faster than ThisForth.  this is not surprising,
because ThisForth was implemented in C, and eForth is fully optimized in
PowerPC assembler.  From these tests, I can conclude that eForth is doing about
40 million primitive Forth instructions per seconds, on an 150 MHz 604e PowerPC
microprocessor, a very respectful performance for a Forth engine.

12. 	Conclusion

PowerPC is a very good microprocessor, in spite of its RISC ancestry.  The
Branch-Link mechanism in the RISC architecture is very useful in the Forth
Virtual Machine because it is exactly what is needed to implement the Forth
inner interpreter NEXT, if we use the Branch-Link instructions as Forth tokens.
The post-incrementing and post-decrementing features in memory accessing
instructions give us a half-decent stack mechanism, and under the
circumstances, we really do not have too much to complain.  An efficient Forth
implementation can bring out very good performance from this microprocessor.
At 40 million Forth instructions per second, this PowerPC eForth is indeed the
fastest Forth I have ever seen.

