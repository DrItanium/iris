PPC eForth Version 1.011.	DerivationThis implementation is derived from the 32-bit 386 eForth system, Version 4.02.  Cells are 4 byte in size, and all fields (name, link, code pointer, and parameter ffields) are aligned to cell boundary.Assembly code for many of the primitive words were transcribed from the Open Firmware Forth Kernel done by Ron Hochsprung of Apple Computers.2.	Forth Virtual Engine on Power PCThe register assignments are:Name		PPC Register		FunctionrTOS		r31			Top of data stackrNOS		r30			Next of data stackrDP		r29			Data stack pointerrLR		r28			Shadow of link registerrTOR		r27			Top of return stackrRP		r26			Return stack pointer rBase		r25			Base address for relocationrUP		r24			User area pointert1:		r23			scratch pad registerst2:		r22			scratch pad registersIt uses the subroutine threaded model, where all the token in the list of a colon definition are branch-link, bl,  instruction of Power PC microprocessor.  NEXT is thus the branch-through-link-register, blr, instruction.  The address field of the bl instruction contains a 26-bit address-offset for relative jumping.  The limit on the size of the Forth dictionary is thus  64M bytes, adequate for all practical purposes.LR register in PPC branch processor is the IP register of the eForth model.The Forth Engine accesses memory using aaddresses relative to the origin of the eForth image in memory.  The absolute address of the origin  is stored in rBase register.  Therefore, this eForth is totally relocatable.3.	Stack CacheBoth the top os the data stack and the top of the return stack are cached in CPU registers.  Having these stack tops in CPU registers optimizes the perfomance of the Forth Virtual Engine and reduces the stack pushing and popping of stacks in run-time.The perfomance improvement stops at caching the top element of a stack.  The management of the second stack item in register actually slows down the stack operatins.4.	Primitive WordsPrimitive words are coded  in the native machine instructions.  In PPC eForth  all words which can be reasonably  implemented in machine instructions are done in assembly.  Here is the list of the primitive words:BYE, ?RX, TX!, !IODOLIT, EXIT, EXECUTE, next, ?branch, @EXECUTE, !, @, C!, C@, +!, 2!, 2@, COUNT, CMOVE, FILL, RRP@, RP!, R>, R@, >RSP@, SP!, DROP, DUP, SWAP, OVER, ?DUP, ROT, 2DROP, 2DUP, PICK,0<, =, U<, <, MAX, MIN, WITHIN,AND, OR, XOR, NOT,UM+, +, D+, NEGATE, DNEGATE, -, ABS, UM/MOD, M/MOD, /MOD, MOD, /, UM*, *, M*, */MOD, */,doVAR, doCON, doUSER, doVOC, FORTH,CELL+, CELL-, CELLS, ALIGNED.There are 73 primitives words.  This set makes PPC eForth run much faster than the eForth model with only 31 primitives.5.	Memory AddressingAddresses pushed on the return stack are absolute addresses.  Addresses visible to the eForth system are relative addresses from the origin of eForth as placed in the memory.  The absolute address of the origin is stored in register rBase.  When coing in assembly, you have to be aware of the two distinct addressing systems.  Normal Forth operations assumes the relative addresses.  Only when you pop address back from the return stack, you have to convert the absolute address to relative address before you can you @ or ! to access the memory.Relative address has the advantage of relocation.  eForth thus can be loaded into any memory region and the code does not need any modification.6.	Input and OutputeForth assumes a serial port for user interaction.  KEY and EMIT are verctored through ?RX and TX! to get charcters from the user and display characters on the appropriate display device.  In PPC eForth, ?RX calls 'read' to get characters from the Mac OS, and TX! calls 'write' to send characters to the Mac OS.  This scheme works fine under MPW.  It may have to be change to run under other environments.It might be desirable to implement a version of KEY and EMIT which talks directly to the keyboard ABD for character imput and to the screen for output.  This will allow the user to control Mac directly for debugging purposes.7.	File InterfaceI like to implement the file-loading mechanism I did for the MIPS eForth.  Then the user can 'INCLUDE' files recursively.  Here the TIB is already made to point to the end of the dictionary space, so that we can allocate as much space for file loatding as necessary.Here is a set of files to test the INCLUDE command:File 1:	.( TEST1 loading all files. )	INCLUDE TEST2	INCLUDE TEST3	: +TEST 1000000 FOR R@ DUP + DROP NEXT ;File 2:	.( TEST2 load TEST4. )	INCLUDE TEST4	: *TEST 1000000 FOR R@ DUP * DROP NEXT ;File 3	.( TEST3 load /TEST. )	: /TEST 1000000 FOR 1000000 R@ / DROP NEXT ;File 4:	.( TEST4 load LOOPTEST. )	: LOOPTEST 1000000 FOR NEXT ;Type INCLUDE TEST1 will load all these test routine in the 4 files.8.	DebuggingPPC eForth provides several entry points to the code image for the convenience of debugging the system when there is trouble.  The entry point DEBUG has an invalid PPC instruction, which will trap to Macsbug.  Set PC to 4 bytes passing DEBUG will start eForth under Macsbug.  There you can use the full suite of Macbug commands to debug eForth and its applications.The command:	0  EXECUTEwill invoke the Macsbug and then you can debug the application using Macsbug.9.	What's Next?PPC eForth must be extended to include all the ANS Forth standard words and the words implemented in aForth so that it can replace ThisForth as the plateform to build OFW.  Here is a list of the most important extensions:	Vocabulary words	Standard DO-LOOP words	Local variables	Conditional compilation words	Run time structures