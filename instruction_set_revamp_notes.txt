So I want to be able to stash a version of this simulator on an AVR processor
for real hardware. I already have the memory array designed via SPI but now I
need to make sure that the decoder logic is a simple as possible. So here are
my ideas.

=== Separate instructions into logical groups ===

This is done with the Intel i960 which has been a huge influence on this revamp
as I really like the design. The separation makes it possible to perform logic
dispatch using the bits of the design to describe what to perform. It removes
the redundant decode problem and also makes it easier to reason about an
instruction for me as a human. Holes in the instruction encoding are also a
part of this as well.

=== Compare operators should have their action encoded into the opcode bits ===

This is one that I noticed recently with the i960 simulator I'm also writing.
The lowest three bits of the major opcode are consistently tied to a given
comparison operation. The instructions are also encoded to make this pattern
usable. For instance:

- 0b000 -> Unordered 
- 0b001 -> Greater
- 0b010 -> Equal
- 0b011 -> Greater or Equal
- 0b100 -> Less
- 0b101 -> Not Equal
- 0b110 -> Less or Equal
- 0b111 -> Ordered


So the first and last bit pattern is meant for numerical operations on real
numbers so we'll ignore them for now. However, the other patterns are
important. We can have a single compare operation and use a table to hold onto
the operation to perform in a constant time lookup. However, the compare
operation itself would still be multiple different compare operations. But that
can be easily solved by the next aspect

=== Reduce the register count to either 128 or 64 ===

256 registers is really nice to have but I think it is really over kill since
we have separate memories. Having fewer registers means that we can have more
control bits to play with. 

Having 128 registers will yield a single bit from each register field which
gives us back a total of three bits to play with. This could be easily used to
denote a literal or register in the instruction. This would cut the number of
instructions which describe variations on a theme significantly. This is an
exact port of the mode bits found in i960. 

Having 64 registers will yield two bits from each register field which gives us
back six bits to play with. In addition to denoting literals or registers for
fields, it also allows us more space to describe more actions and even extend
the number of instructions if needed. This is a pretty decent compromise but I
think that it is pretty nice to have. 

The encoding will remain the same due to the fact that it is cheaper to mask
out in this fashion.

Going with 32 registers is also an idea as well. It would give us nine bits to
work with and be even closer to i960 in design. I believe that having that few
of registers in this design would be a detriment to the design. The large
number of registers is meant to keep as much on the chip as possible. Even 64
registers is pushing it to be honest.


=== Move opcode from the lowest eight bits of the encoding to the highest eight bits of the encoding===

This makes reasoning about what instruction is being viewed even easier as we
only have to look at the most significant two hex numbers to get an idea of
what the instruction is.

=== Use mode bits freed from register count reduction to eliminate variations on instructions ===

For instance, the load and store instructions are really the same in all cases,
with the difference being which memory space to write to. For example, if we
encode the space into the instruction then we only need single copies of load
and store. The extra mode bits tell the simulator what to do.



The major opcode is 8 bits wide with the upper four bits denoting a group. Here
are the known groups at this time
0000 -> error 
0001 -> arithmetic
0010 -> branch
0011 -> compare
0111 -> memory

Any groups not specified here are undefined

The lower four bits are the action

arithmetic action bits:

0b0000 -> add
0b0001 -> subtract
0b0010 -> multiply
0b0011 -> divide 
0b0100 -> remainder
0b0101 -> shift-left 
0b0110 -> shift-right
0b0111 -> unused
0b1000 -> max
0b1001 -> min
0b1010 -> not
0b1011 -> and
0b1100 -> or
0b1101 -> nor
0b1111 -> nand

All arithmetic operations follow the same basic format for the mode bits

0b000000 -> registers[dest] = registers[src0] op registers[src1] // 3 register ordinal
0b000001 -> registers[dest] = registers[src0] op registers[src1] // 3 register integer
0b000010 -> registers[dest] = registers[src0] op src1 // 2 register ordinal with Ordinal immediate
0b000011 -> registers[dest] = registers[src0] op src1 // 2 register integer with Integer immediate
0b000100 -> wide(registers[dest]) = wide(registers[src0]) op wide(registers[src1]) // 3 register wide ordinal 
0b000101 -> wide(registers[dest]) = wide(registers[src0]) op src1 // 2 register wide ordinal with immediate
0b000110 -> wide(registers[dest]) = wide(registers[src0]) op wide(registers[src1]) // 3 register wide integer
0b000111 -> wide(registers[dest]) = wide(registers[src0]) op wide(registers[src1]) // 2 register wide integer with immediate
0b001xxx -> simd version, operates on register pairs and performs the operation to two sets of instructions
0b001000 -> registers[dest][0] = registers[src0][0] op registers[src1][0] // ordinal version
            registers[dest][1] = registers[src0][1] op registers[src1][1]
0b001001 -> registers[dest][0] = registers[src0][0] op registers[src1][0] // integer version
            registers[dest][1] = registers[src0][1] op registers[src1][1]
0b001010 -> registers[dest][0] = registers[src0][0] op src1 // ordinal version with immediate 
            registers[dest][1] = registers[src0][1] op src1
0b001011 -> registers[dest][0] = registers[src0][0] op src1 // integer version with immediate 
            registers[dest][1] = registers[src0][1] op src1
// 4 simd version
0b001100 -> registers[dest][0] = registers[src0][0] op registers[src1][0] // ordinal version
            registers[dest][1] = registers[src0][1] op registers[src1][1]
            registers[dest][2] = registers[src0][2] op registers[src1][2]
            registers[dest][3] = registers[src0][3] op registers[src1][3]
0b001101 -> registers[dest][0] = registers[src0][0] op registers[src1][0] // integer version
            registers[dest][1] = registers[src0][1] op registers[src1][1]
            registers[dest][2] = registers[src0][2] op registers[src1][2]
            registers[dest][3] = registers[src0][3] op registers[src1][3]
0b001110 -> registers[dest][0] = registers[src0][0] op src1 // ordinal version with immediate 
            registers[dest][1] = registers[src0][1] op src1
            registers[dest][2] = registers[src0][2] op src1
            registers[dest][3] = registers[src0][3] op src1
0b001111 -> registers[dest][0] = registers[src0][0] op src1 // integer version with immediate 
            registers[dest][1] = registers[src0][1] op src1
            registers[dest][2] = registers[src0][2] op src1
            registers[dest][3] = registers[src0][3] op src1

Any other encodings in the mode bits are not accepted

The memory group has the following opcodes:

0b0000 - set
0b0001 - move
0b0010 - swap
0b1xxx - load/store (see below)


Set has very few mode bits due to it being an immediate interfacing instruction
The mode bits provide ways to manipulate multiple registers simultaneously
0b00xxxx -> registers[dest] = imm16
0b01xxxx -> registers[dest+0] = imm16
            registers[dest+1] = imm16
0b10xxxx -> registers[dest+0] = imm16
            registers[dest+1] = imm16
            registers[dest+2] = imm16
0b11xxxx -> registers[dest+0] = imm16
            registers[dest+1] = imm16
            registers[dest+2] = imm16
            registers[dest+4] = imm16

move is a two register instruction, thus we actually have a lot more mode bits
than would usually be available, however that really isn't that useful. Src1
must always be all zeros. 

0b000000 -> registers[dest] = registers[src0]
0b000100 -> registers[dest] = registers[src0]
          registers[dest+1] = registers[src0+1]
0b001000 -> registers[dest] = registers[src0]
          registers[dest+1] = registers[src0+1]
          registers[dest+2] = registers[src0+2]
0b001100 -> registers[dest] = registers[src0]
          registers[dest+1] = registers[src0+1]
          registers[dest+2] = registers[src0+2]
          registers[dest+3] = registers[src0+3]

IP and LR are hidden registers which are not directly accessible. Instead you
must use move with the mode bit for dest set to 0b01. This acts as another
register "file". Conceptually the internal registers are defined as this:

register 64 -> IP
register 65 -> LR
0b01'000000'00'xxxxxx -> ip = registers[src0] // move to ip
0b01'xxxxxx'01'000000 -> registers[dest] = ip // move from ip
0b01'000001'00'xxxxxx -> lr = registers[src0] // move to lr
0b01'xxxxxx'01'000001 -> registers[dest] = lr // move from lr

The actual memory load/store parent code is actually 0b01111yyx

With x:
0b0 -> load
0b1 -> store
with Y:
0b00 -> code
0b01 -> data
0b10 -> stack
0b11 -> io

While code is special due it being double wide, the other memory spaces have
the following control bits:

mode bits (combined, undeclared bits are unused error states)
0b000000 -> address (dest) + immediate offset (src1), value is register src0
0b000010 -> address (dest) + register offset (src1), value is register src0
0b000100 -> address (dest) + immediate offset (src1), value is register src0, then increment dest
0b000101 -> address (dest) + immediate offset (src1), value is register src0, first increment dest
0b000110 -> address (dest) + register offset (src1), value is register src0,  then increment dest
0b000111 -> address (dest) + register offset (src1), value is register src0,  first increment dest
0b001000 -> address (dest) + immediate offset (src1), value is register src0, then decrement dest
0b001001 -> address (dest) + immediate offset (src1), value is register src0, first decrement dest
0b001010 -> address (dest) + register offset (src1), value is register src0,  then decrement dest
0b001011 -> address (dest) + register offset (src1), value is register src0,  first decrement dest
0b001100 -> address (dest) + immediate offset (src1), value is register pair src0
0b001110 -> address (dest) + register offset (src1), value is register pair src0
0b010000 -> address (dest), value is register (src0), mask is register (src1), value & mask is performed
0b11xxxx -> address (dest), value is imm16


The code space has the following mode bits

0b000000 -> address (dest), lower half (src0), upper half (src1)
0b000010 -> address (dest), lower half (src0), upper half (src1) then incr dest
0b000011 -> address (dest), lower half (src0), upper half (src1) then decr dest
0b000100 -> address (dest), pair lower half (src0), offset immediate (src1) 
0b000110 -> address (dest), pair lower half (src0), offset immediate (src1) then incr dest
0b000111 -> address (dest), pair lower half (src0), offset immediate (src1) then decr dest
0b001000 -> address (dest), pair lower half (src0), offset register (src1) 
0b001010 -> address (dest), pair lower half (src0), offset register (src1) then incr dest
0b001011 -> address (dest), pair lower half (src0), offset register (src1) then decr dest
0b11xxxx -> address (imm16), pair lower half (dest)

Compare operations are very simple too

The major group is 0b0011 with the actual action set being 0b0011yyyx

where x is the comparison type (Ordinal or Integer)
0b0 -> Ordinal
0b1 -> Integer

where yyy is the comparison operation
0b000 -> Equals
0b001 -> NotEquals
0b010 -> Less Than
0b011 -> Less Than or Equal
0b100 -> Greater Than
0b101 -> Greater Than or Equal

The mode bits of the compare are as follows:

dest ctrl: 
0b00 -> Dest is Register
0b01 -> Dest is Register (inverse result)
0b10 -> Dest is Register Pair (dest is result, dest+1 is inverse)
0b11 -> Dest is Register Pair (dest is inverse result, dest+1 is result)

src0 ctrl:
0b00 -> Src0 is Register
0b01 -> Src0 is Immediate
0b10 -> Src0 is Double Register
0b11 -> unused

src1 ctrl:
0b00 -> Src1 is Register
0b01 -> Src1 is Immediate
0b10 -> Src1 is Double Register
0b11 -> unused




