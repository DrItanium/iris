So I want to be able to stash a version of this simulator on an AVR processor
for real hardware. I already have the memory array designed via SPI but now I
need to make sure that the decoder logic is a simple as possible. So here are
my ideas.

=== Separate instructions into logical groups ===

This is done with the Intel i960 which has been a huge influence on this revamp
as I really like the design. The separation makes it possible to perform logic
dispatch using the bits of the design to describe what to perform. It removes
the redundant decode problem and also makes it easier to reason about an
instruction for me as a human. Holes in the instruction encoding are also a
part of this as well.

=== Compare operators should have their action encoded into the opcode bits ===

This is one that I noticed recently with the i960 simulator I'm also writing.
The lowest three bits of the major opcode are consistently tied to a given
comparison operation. The instructions are also encoded to make this pattern
usable. For instance:

- 0b000 -> Unordered 
- 0b001 -> Greater
- 0b010 -> Equal
- 0b011 -> Greater or Equal
- 0b100 -> Less
- 0b101 -> Not Equal
- 0b110 -> Less or Equal
- 0b111 -> Ordered


So the first and last bit pattern is meant for numerical operations on real
numbers so we'll ignore them for now. However, the other patterns are
important. We can have a single compare operation and use a table to hold onto
the operation to perform in a constant time lookup. However, the compare
operation itself would still be multiple different compare operations. But that
can be easily solved by the next aspect

=== Reduce the register count to either 128 or 64 ===

256 registers is really nice to have but I think it is really over kill since
we have separate memories. Having fewer registers means that we can have more
control bits to play with. 

Having 128 registers will yield a single bit from each register field which
gives us back a total of three bits to play with. This could be easily used to
denote a literal or register in the instruction. This would cut the number of
instructions which describe variations on a theme significantly. This is an
exact port of the mode bits found in i960. 

Having 64 registers will yield two bits from each register field which gives us
back six bits to play with. In addition to denoting literals or registers for
fields, it also allows us more space to describe more actions and even extend
the number of instructions if needed. This is a pretty decent compromise but I
think that it is pretty nice to have. 

The encoding will remain the same due to the fact that it is cheaper to mask
out in this fashion.

Going with 32 registers is also an idea as well. It would give us nine bits to
work with and be even closer to i960 in design. I believe that having that few
of registers in this design would be a detriment to the design. The large
number of registers is meant to keep as much on the chip as possible. Even 64
registers is pushing it to be honest.


=== Move opcode from the lowest eight bits of the encoding to the highest eight bits of the encoding===

This makes reasoning about what instruction is being viewed even easier as we
only have to look at the most significant two hex numbers to get an idea of
what the instruction is.

=== Use mode bits freed from register count reduction to eliminate variations on instructions ===

For instance, the load and store instructions are really the same in all cases,
with the difference being which memory space to write to. For example, if we
encode the space into the instruction then we only need single copies of load
and store. The extra mode bits tell the simulator what to do.



The major opcode is 8 bits wide with the upper four bits denoting a group. Here
are the known groups at this time
0000 -> error 
0001 -> arithmetic
0010 -> branch
0011 -> compare
0111 -> memory

Any groups not specified here are undefined

The lower four bits are the action

arithmetic action bits:

0b0000 -> add
0b0001 -> subtract
0b0010 -> multiply
0b0011 -> divide 
0b0100 -> remainder
0b0101 -> shift-left 
0b0110 -> shift-right
0b0111 -> unused
0b1000 -> max
0b1001 -> min
0b1010 -> not
0b1011 -> and
0b1100 -> or
0b1101 -> nor
0b1111 -> nand

All arithmetic operations follow the same basic format for the mode bits

0b000000 -> registers[dest] = registers[src0] op registers[src1] // 3 register ordinal
0b000001 -> registers[dest] = registers[src0] op src1 // 2 register ordinal with Ordinal immediate
0b010000 -> registers[dest] = registers[src0] op registers[src1] // 3 register integer
0b010001 -> registers[dest] = registers[src0] op src1 // 2 register integer with Integer immediate
0b100000 -> wide(registers[dest]) = wide(registers[src0]) op wide(registers[src1]) // 3 register wide ordinal 
0b100001 -> wide(registers[dest]) = wide(registers[src0]) op src1 // 2 register wide ordinal with immediate
0b110000 -> wide(registers[dest]) = wide(registers[src0]) op wide(registers[src1]) // 3 register wide integer
0b110001 -> wide(registers[dest]) = wide(registers[src0]) op wide(registers[src1]) // 2 register wide integer with immediate
Any other encodings in the mode bits are not accepted

The actual memory load/store parent code is actually 0b01111yyx

With x:
0b0 -> load
0b1 -> store
with Y:
0b00 -> code
0b01 -> data
0b10 -> stack
0b11 -> io

While code is special due it being double wide, the other memory spaces have
the following control bits:

mode bits (combined)
0b000000 -> address (dest) + immediate offset (src2), value is register src1
0b000001 -> unused
0b000010 -> address (dest) + register offset (src2), value is register src1
0b000011 -> unused
0b000100 -> address (dest) + immediate offset (src2), value is register src1, then increment dest
0b000101 -> address (dest) + immediate offset (src2), value is register src1, first increment dest
0b000110 -> address (dest) + register offset (src2), value is register src1,  then increment dest
0b000111 -> address (dest) + register offset (src2), value is register src1,  first increment dest
0b001000 -> address (dest) + immediate offset (src2), value is register src1, then decrement dest
0b001001 -> address (dest) + immediate offset (src2), value is register src1, first decrement dest
0b001010 -> address (dest) + register offset (src2), value is register src1,  then decrement dest
0b001011 -> address (dest) + register offset (src2), value is register src1,  first decrement dest
0b001100 -> address (dest) + immediate offset (src2), value is register pair src1
0b001101 -> unused
0b001110 -> address (dest) + register offset (src2), value is register pair src1
0b001111 -> unused
0b01xxxx -> unused
0b10xxxx -> address (dest), value is imm16
0b11xxxx -> address (imm16), value (dest)


Compare operations are very simple too

The major group is 0b0011 with the actual action set being 0b0011yyyx

where x is the comparison type (Ordinal or Integer)
0b0 -> Ordinal
0b1 -> Integer

where yyy is the comparison operation
0b000 -> Equals
0b001 -> NotEquals
0b010 -> Less Than
0b011 -> Less Than or Equal
0b100 -> Greater Than
0b101 -> Greater Than or Equal

The mode bits of the compare are as follows:

dest ctrl: 
0b00 -> Dest is Register
0b01 -> Dest is Register (inverse result)
0b10 -> Dest is Register Pair (dest is result, dest+1 is inverse)
0b11 -> Dest is Register Pair (dest is inverse result, dest+1 is result)

src0 ctrl:
0b00 -> Src0 is Register
0b01 -> Src0 is Immediate
0b10 -> Src0 is Double Register
0b11 -> unused

src1 ctrl:
0b00 -> Src1 is Register
0b01 -> Src1 is Immediate
0b10 -> Src1 is Double Register
0b11 -> unused

Table
|------------|----------|------|------|------|----------------------------------------------------------------
| Operation  | opcode   | dest | src0 | src1 | description via psuedo code
|            | bits     | ctrl | ctrl | ctrl |
|            | [31,24]  |      |      |      |
|------------|----------|------|------|------|----------------------------------------------------------------
| Error      | 0000xxxx | 0bxx | 0bxx | 0bxx | Throw Exception / Raise Fault not allowed
|------------|----------|------|------|------|----------------------------------------------------------------
| CodeLoad   | 01111000 | 0b00 | 0b00 | 0b00 | unpackWide(code[registers[src1]], registers[dest], registers[src0])
|------------|----------|------|------|------|----------------------------------------------------------------
| CodeLoad   | 01111000 | 0b00 | 0b00 | 0b01 | unpackWide(code[registers[src1]], registers[dest], registers[src0])
| AndIncr    |          |      |      |      | ++registers[src1]
|------------|----------|------|------|------|----------------------------------------------------------------
| CodeLoad   | 01111000 | 0b00 | 0b00 | 0b10 | unpackWide(code[registers[src1]], registers[dest], registers[src0])
| AndDecr    |          |      |      |      | --registers[src1]
|------------|----------|------|------|------|----------------------------------------------------------------
| CodeLoad   | 01111000 | 0b01 | 0b00 | 0b00 | addr = registers[src1] + Ordinal(src0)
| DestPair   |          |      |      |      | unpackWide(addr, registers[dest], registers[dest+1])
| OrdOffset  |          |      |      |      | Note: use an offset of zero for normal code load
|------------|----------|------|------|------|----------------------------------------------------------------
| CodeLoad   | 01111000 | 0b01 | 0b01 | 0b00 | addr = registers[src1] + Integer(src0)
| DestPair   |          |      |      |      | unpackWide(addr, registers[dest], registers[dest+1])
| IntOffset  |          |      |      |      | Note: use an offset of zero for normal code load
|------------|----------|------|------|------|----------------------------------------------------------------
| CodeLoad   | 01111000 | 0b01 | 0b10 | 0b00 | addr = registers[src1] + Ordinal(registers[src0])
| DestPair   |          |      |      |      | unpackWide(addr, registers[dest], registers[dest+1])
| RegOrdOff  |          |      |      |      | Note: use an offset of zero for normal code load
|------------|----------|------|------|------|----------------------------------------------------------------
| CodeLoad   | 01111000 | 0b01 | 0b11 | 0b00 | addr = registers[src1] + Integer(registers[src0])
| DestPair   |          |      |      |      | unpackWide(addr, registers[dest], registers[dest+1])
| RegIntOff  |          |      |      |      | Note: use an offset of zero for normal code load
|------------|----------|------|------|------|----------------------------------------------------------------
| CodeLoad   | 01111000 | 0b01 | 0b00 | 0b01 | addr = registers[src1] + Ordinal(src0)
| DestPair   |          |      |      |      | unpackWide(addr, registers[dest], registers[dest+1])
| OrdOffset  |          |      |      |      | 
| IncrAddr   |          |      |      |      | ++registers[src1]
|------------|----------|------|------|------|----------------------------------------------------------------
| CodeLoad   | 01111000 | 0b01 | 0b01 | 0b01 | addr = registers[src1] + Integer(src0)
| DestPair   |          |      |      |      | unpackWide(addr, registers[dest], registers[dest+1])
| IntOffset  |          |      |      |      | 
| IncrAddr   |          |      |      |      | ++registers[src1]
|------------|----------|------|------|------|----------------------------------------------------------------
| CodeLoad   | 01111000 | 0b01 | 0b10 | 0b01 | addr = registers[src1] + Ordinal(registers[src0])
| DestPair   |          |      |      |      | unpackWide(addr, registers[dest], registers[dest+1])
| RegOrdOff  |          |      |      |      | Note: use an offset of zero for normal code load
| IncrAddr   |          |      |      |      | ++registers[src1]
|------------|----------|------|------|------|----------------------------------------------------------------
| CodeLoad   | 01111000 | 0b01 | 0b11 | 0b01 | addr = registers[src1] + Integer(registers[src0])
| DestPair   |          |      |      |      | unpackWide(addr, registers[dest], registers[dest+1])
| RegIntOff  |          |      |      |      | Note: use an offset of zero for normal code load
| IncrAddr   |          |      |      |      | ++registers[src1]
|------------|----------|------|------|------|----------------------------------------------------------------
| CodeLoad   | 01111000 | 0b01 | 0b00 | 0b10 | addr = registers[src1] + Ordinal(src0)
| DestPair   |          |      |      |      | unpackWide(addr, registers[dest], registers[dest+1])
| OrdOffset  |          |      |      |      | 
| DecrAddr   |          |      |      |      | --registers[src1]
|------------|----------|------|------|------|----------------------------------------------------------------
| CodeLoad   | 01111000 | 0b01 | 0b01 | 0b10 | addr = registers[src1] + Integer(src0)
| DestPair   |          |      |      |      | unpackWide(addr, registers[dest], registers[dest+1])
| IntOffset  |          |      |      |      | 
| DecrAddr   |          |      |      |      | --registers[src1]
|------------|----------|------|------|------|----------------------------------------------------------------
| CodeLoad   | 01111000 | 0b01 | 0b10 | 0b10 | addr = registers[src1] + Ordinal(registers[src0])
| DestPair   |          |      |      |      | unpackWide(addr, registers[dest], registers[dest+1])
| RegOrdOff  |          |      |      |      | Note: use an offset of zero for normal code load
| DecrAddr   |          |      |      |      | --registers[src1]
|------------|----------|------|------|------|----------------------------------------------------------------
| CodeLoad   | 01111000 | 0b01 | 0b11 | 0b10 | addr = registers[src1] + Integer(registers[src0])
| DestPair   |          |      |      |      | unpackWide(addr, registers[dest], registers[dest+1])
| RegIntOff  |          |      |      |      | Note: use an offset of zero for normal code load
| DecrAddr   |          |      |      |      | --registers[src1]
|------------|----------|------|------|------|----------------------------------------------------------------
| CodeLoad   | 01111000 | 0b11 | 0bxx | 0bxx | unpackWide(code[imm16], registers[dest], registers[dest+1])
| Imm16Addr  |          |      |      |      | NOTE: src0ctrl and src1ctrl are part of the imm16 value
| DestPair   |          |      |      |      | 
|------------|----------|------|------|------|----------------------------------------------------------------
| DataLoad   | 01111010 | 0b00 | 0b00 | 0b00 | addr = registers[src0] + Ordinal(src1)
| OrdOffset  |          |      |      |      | registers[dest] = data[addr]
|            |          |      |      |      | Note: use an offset of zero for normal code load
|------------|----------|------|------|------|----------------------------------------------------------------
| DataLoad   | 01111010 | 0b00 | 0b00 | 0b01 | addr = registers[src0] + Integer(src1)
| IntOffset  |          |      |      |      | registers[dest] = data[addr]
|------------|----------|------|------|------|----------------------------------------------------------------
| DataLoad   | 01111010 | 0b00 | 0b00 | 0b10 | addr = registers[src0] + Ordinal(registers[src1])
| RegOrdOff  |          |      |      |      | registers[dest] = data[addr]
|------------|----------|------|------|------|----------------------------------------------------------------
| DataLoad   | 01111010 | 0b00 | 0b00 | 0b11 | addr = registers[src0] + Integer(registers[src1])
| RegImmOff  |          |      |      |      | registers[dest] = data[addr]
|------------|----------|------|------|------|----------------------------------------------------------------
| CodeStore  | 01111001 | 0b00 | 0b00 | 0b00 | code[registers[dest]] = mkwide(registers[src0], registers[src1])
|------------|----------|------|------|------|----------------------------------------------------------------
| CodeStore  | 01111001 | 0b00 | 0b01 | 0b00 | addr = registers[dest] + registers[src1]
| SrcPair    |          |      |      |      | code[addr] = mkwide(registers[src0], registers[src0+1])
| ImmOffset  |          |      |      |      | Note: use an offset of zero for normal code store
|------------|----------|------|------|------|----------------------------------------------------------------
| CodeStore  | 01111001 | 0b00 | 0b01 | 0b01 | addr = registers[dest] + registers[src1]
| SrcPair    |          |      |      |      | code[addr] = mkwide(registers[src0], registers[src0+1])
| RegOffset  |          |      |      |      | 
|------------|----------|------|------|------|----------------------------------------------------------------
| CodeStore  | 01111001 | 0b11 | 0bxx | 0bxx | code[imm16] = mkwide(registers[src0], registers[src0+1])
| Imm16Addr  |          |      |      |      | NOTE: src0ctrl and src1ctrl are part of the imm16 value
| SrcPair    |          |      |      |      | 
|------------|----------|------|------|------|----------------------------------------------------------------
| DataStore  | 01111011 | 0b00 | 0b00 | 0b00 | data[registers[dest]] = registers[src0]
|------------|----------|------|------|------|----------------------------------------------------------------
| StackStore | 01111101 | 0b00 | 0b00 | 0b00 | registers[dest] = registers[dest] + 1
| (Push)     |          |      |      |      | stack[registers[dest]] = registers[src0]
|------------|----------|------|------|------|----------------------------------------------------------------
| IOStore    | 01111111 | 0b00 | 0b00 | 0b00 | io[registers[dest]] = registers[src0]
|------------|----------|------|------|------|----------------------------------------------------------------



